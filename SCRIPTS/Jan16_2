Script started on 2026-01-19 03:47:39+05:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="80" LINES="24"]
[?2004h]0;xainecks@xainecks-PC1: ~/XDP/SCRIPTS[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/SCRIPTS[00m$ cd ../
[?2004l[?2004h]0;xainecks@xainecks-PC1: ~/XDP[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP[00m$ cd xdp-tutorial/
[?2004l[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial[00m$ ls
[?2004l[0m[01;34madvanced01-xdp-tc-interact[0m  [01;32mconfigure[0m              README.org
[01;34madvanced03-AF_XDP[0m           [01;34mexperiment01-tailgrow[0m  setup_dependencies.org
[01;34mbasic01-xdp-pass[0m            [01;34minstall[0m                [01;34msetup-testlab[0m
[01;34mbasic02-prog-by-name[0m        [01;34mlib[0m                    [01;34mtestenv[0m
[01;34mbasic03-map-counter[0m         Makefile               [01;34mtracing01-xdp-simple[0m
[01;34mbasic04-pinning-maps[0m        [01;34mpacket01-parsing[0m       [01;34mtracing02-xdp-monitor[0m
[01;34mbasic-solutions[0m             [01;34mpacket02-rewriting[0m     [01;34mtracing03-xdp-debug-print[0m
[01;34mcommon[0m                      [01;34mpacket03-redirecting[0m   [01;34mtracing04-xdp-tcpdump[0m
config.mk                   [01;34mpacket-solutions[0m
[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial[00m$ cd basci[K[Kic m[K[K03-map-counter/
[?2004l[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ ls
[?2004lcommon_kern_user.h  README.org          xdp_load_and_stats.c  xdp_prog_kern.o
Makefile            [0m[01;32mxdp_load_and_stats[0m  xdp_prog_kern.c
[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ ls
[?2004lcommon_kern_user.h  README.org          xdp_load_and_stats.c  xdp_prog_kern.o
Makefile            [0m[01;32mxdp_load_and_stats[0m  xdp_prog_kern.c
[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ nano xdp_prog_kern.c
[?2004l[?2004h[?1049h[22;0;0t[1;24r(B[m[4l[?7h[39;49m[?1h=[?1h=[?25l[39;49m(B[m[H[2J[22;34H(B[0;7m[ Reading... ](B[m[22;32H(B[0;7m[ Read 85 lines ](B[m[H(B[0;7m  GNU nano 7.2                     xdp_prog_kern.c                              [1;79H(B[m[23d(B[0;7m^G(B[m Help[14G(B[0;7m^O(B[m Write Out (B[0;7m^W(B[m Where Is  (B[0;7m^K(B[m Cut[53G(B[0;7m^T(B[m Execute   (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^R(B[m Read File (B[0;7m^\(B[m Replace   (B[0;7m^U(B[m Paste     (B[0;7m^J(B[m Justify   (B[0;7m^/(B[m Go To Line[2d(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d[36m#include[33m <linux/bpf.h>[4d[36m#include[33m <bpf/bpf_helpers.h>[6d[36m#include[39m(B[m (B[0;1m[33m"common_kern_user.h"[39m(B[m (B[0;1m[34m/* defines: struct datarec; */[8d/* Lesson#1: See how a map is defined.[9d * - Here an array with XDP_ACTION_MAX (max_)entries are created.[10d * - The idea is to keep stats per (enum) xdp_action[11d */[12d(B[0m[32mstruct[39m(B[m {[13d__uint(type, (B[0;1m[31mBPF_MAP_TYPE_ARRAY[39m(B[m);[14;9H__type(key, __u32);[15;9H__type(value, [32mstruct[39m(B[m datarec);[16;9H__uint(max_entries, (B[0;1m[31mXDP_ACTION_MAX[39m(B[m);[17d} xdp_stats_map (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m".maps"[39m(B[m);[19d(B[0;1m[34m/* LLVM maps __sync_fetch_and_add() as a built-in function to the BPF atomic add[20;1H * instruction (that is BPF_STX | BPF_XADD | BPF_W for word sizes)[21d */[2d[39m(B[m[?12l[?25h[?25l[?12l[?25h[5d[?25l[?12l[?25h[8d[?25l[?12l[?25h[11d[?25l[?12l[?25h[14d[?25l[?12l[?25h[17d[?25l[?12l[?25h[20d[?25l[22d[K[?12l[?25h7[2;22r8[2S[1;24r[20;1H(B[0;1m[36m#ifndef lock_xadd[21d#define[39m(B[m lock_xadd(ptr, val)     (([32mvoid[39m(B[m) __sync_fetch_and_add(ptr, val))[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[36m#endif[21d[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[20d{[21;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m// void *data     = (void *)(long)ctx->data;[20;9H(B[0m[32mstruct[39m(B[m datarec *rec;[21;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[20;9H(B[0;1m[34m/* Lookup in kernel BPF-side return pointer to actual data record */[21;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[20;9H[1K * check isn't performed here. Even-though this is a static array where[21;9H[1K * we know key lookup XDP_PASS always will succeed.[39m(B[m[?25l[?12l[?25h[18d[?25l[?12l[?25h[15d[?25l[?12l[?25h[12d[?25l[?12l[?25h[9d[?25l[?12l[?25h[6d[?25l[?12l[?25h[3d[?25l[?12l[?25h[2;21r[2;1H[2T[1;24r[2;1H} xdp_stats_map (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m".maps"[39m(B[m);[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;9H__type(key, __u32);[3;9H__type(value, [32mstruct[39m(B[m datarec);[4;9H__uint(max_entries, (B[0;1m[31mXDP_ACTION_MAX[39m(B[m);[2d[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H(B[0;1m[34m */[3d(B[0m[32mstruct[39m(B[m {[4d__uint(type, (B[0;1m[31mBPF_MAP_TYPE_ARRAY[39m(B[m);[2d[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H(B[0;1m[34m/* Lesson#1: See how a map is defined.[3d * - Here an array with XDP_ACTION_MAX (max_)entries are created.[4d * - The idea is to keep stats per (enum) xdp_action[2d[39m(B[m[?25l[?12l[?25h7[2;22r8[3T[1;24r[3;1H(B[0;1m[36m#include[39m(B[m (B[0;1m[33m"common_kern_user.h"[39m(B[m (B[0;1m[34m/* defines: struct datarec; */[A[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d[36m#include[33m <linux/bpf.h>[4d[36m#include[33m <bpf/bpf_helpers.h>[2d[39m(B[m[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[5d[?25l[?12l[?25h[8d[?25l[?12l[?25h[11d[?25l[?12l[?25h[14d[?25l[?12l[?25h[17d[?25l[?12l[?25h[20d[?25l[?12l[?25h[2;22r[22;1H[2S[1;24r[20;1H(B[0;1m[36m#ifndef lock_xadd[21d#define[39m(B[m lock_xadd(ptr, val)     (([32mvoid[39m(B[m) __sync_fetch_and_add(ptr, val))[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[36m#endif[21d[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[20d{[21;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m// void *data     = (void *)(long)ctx->data;[20;9H(B[0m[32mstruct[39m(B[m datarec *rec;[21;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[20;9H(B[0;1m[34m/* Lookup in kernel BPF-side return pointer to actual data record */[21;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[20;9H[1K * check isn't performed here. Even-though this is a static array where[21;9H[1K * we know key lookup XDP_PASS always will succeed.[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K */[20;9H[33mif[39m(B[m (!rec)[21d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[39m(B[m[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                     xdp_prog_kern.c                               [1;80H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[14G(B[0;7m^O(B[m Write Out (B[0;7m^W(B[m Where Is  (B[0;7m^K(B[m Cut[53G(B[0;7m^T(B[m Execute   (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^R(B[m Read File (B[0;7m^\(B[m Replace   (B[0;7m^U(B[m Paste     (B[0;7m^J(B[m Justify   (B[0;7m^/(B[m Go To Line[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                     xdp_prog_kern.c                              [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[14G(B[0;7m^O(B[m Write Out (B[0;7m^W(B[m Where Is  (B[0;7m^K(B[m Cut[53G(B[0;7m^T(B[m Execute   (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^R(B[m Read File (B[0;7m^\(B[m Replace   (B[0;7m^U(B[m Paste     (B[0;7m^J(B[m Justify   (B[0;7m^/(B[m Go To Line[H[?2004h[?1h=[?1h=[23d[J[1;36H(B[0;7m xdp_prog_kern.c[81G  [1;81H(B[m[23d(B[0;7m^G(B[m Help[14G(B[0;7m^O(B[m Write Out (B[0;7m^W(B[m Where Is  (B[0;7m^K(B[m Cut[53G(B[0;7m^T(B[m Execute   (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^R(B[m Read File (B[0;7m^\(B[m Replace   (B[0;7m^U(B[m Paste     (B[0;7m^J(B[m Justify   (B[0;7m^/(B[m Go To Line[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                      xdp_prog_kern.c                              [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[14G(B[0;7m^O(B[m Write Out (B[0;7m^W(B[m Where Is  (B[0;7m^K(B[m Cut[53G(B[0;7m^T(B[m Execute   (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^R(B[m Read File (B[0;7m^\(B[m Replace   (B[0;7m^U(B[m Paste     (B[0;7m^J(B[m Justify   (B[0;7m^/(B[m Go To Line[H[?2004h[?1h=[?1h=[23d[J[1;82H(B[0;7m  [1;82H(B[m[23d(B[0;7m^G(B[m Help[14G(B[0;7m^O(B[m Write Out (B[0;7m^W(B[m Where Is  (B[0;7m^K(B[m Cut[53G(B[0;7m^T(B[m Execute   (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^R(B[m Read File (B[0;7m^\(B[m Replace   (B[0;7m^U(B[m Paste     (B[0;7m^J(B[m Justify   (B[0;7m^/(B[m Go To Line[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                      xdp_prog_kern.c                               [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[14G(B[0;7m^O(B[m Write Out (B[0;7m^W(B[m Where Is  (B[0;7m^K(B[m Cut[53G(B[0;7m^T(B[m Execute   (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[14G(B[0;7m^R(B[m Read File (B[0;7m^\(B[m Replace   (B[0;7m^U(B[m Paste     (B[0;7m^J(B[m Justify   (B[0;7m^/(B[m Go To Line[H[?2004h[?1h=[?1h=[23d[J[1;37H(B[0;7m  xdp_prog_kern.c[83G    [1;85H(B[m[23d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[23;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                        xdp_prog_kern.c                              [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[23;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line[H[?2004h[?1h=[?1h=[23d[J[1;39H(B[0;7m xdp_prog_kern.c[84G     [1;87H(B[m[23d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[23;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                         xdp_prog_kern.c                                [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[23;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line[H[?2004h[?1h=[?1h=[23d[J[1;40H(B[0;7m xdp_prog_kern.c[87G    [1;89H(B[m[23d(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                          xdp_prog_kern.c                                 [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line[H[?2004h[?1h=[?1h=[23d[J[1;41H(B[0;7m xdp_prog_kern.c[89G     [1;92H(B[m[23d(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                           xdp_prog_kern.c                                  [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line[H[?2004h[?1h=[?1h=[23d[J[1;42H(B[0;7m  xdp_prog_kern.c[91G       [1;96H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                             xdp_prog_kern.c                                   [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line[H[?2004h[?1h=[?1h=[23d[J[1;44H(B[0;7m  xdp_prog_kern.c[94G        [1;100H(B[m[23d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[23;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                               xdp_prog_kern.c                                     [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[23;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[H[?2004h[?1h=[?1h=[23d[J[1;46H(B[0;7m xdp_prog_kern.c[98G      [1;102H(B[m[23d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[23;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                xdp_prog_kern.c                                        [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[23;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[H[?2004h[?1h=[?1h=[23d[J[1;47H(B[0;7m  xdp_prog_kern.c[102G     [1;105H(B[m[23d(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                  xdp_prog_kern.c                                        [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[H[?2004h[?1h=[?1h=[23d[J[1;49H(B[0;7m xdp_prog_kern.c[104G      [1;108H(B[m[23d(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                   xdp_prog_kern.c                                          [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[H[?2004h[?1h=[?1h=[23d[J[1;50H(B[0;7m  xdp_prog_kern.c[107G      [1;111H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                     xdp_prog_kern.c                                           [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[H[?2004h[?1h=[?1h=[23d[J[1;52H(B[0;7m xdp_prog_kern.c[110G      [1;114H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                      xdp_prog_kern.c                                             [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[H[?2004h[?1h=[?1h=[23d[J[1;53H(B[0;7m  xdp_prog_kern.c[113G       [1;118H(B[m[23d(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                        xdp_prog_kern.c                                              [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[H[?2004h[?1h=[?1h=[23d[J[1;55H(B[0;7m xdp_prog_kern.c[116G      [1;120H(B[m[23d(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                         xdp_prog_kern.c                                                 [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[H[?2004h[?1h=[?1h=[23d[J[1;56H(B[0;7m xdp_prog_kern.c[120G    [1;122H(B[m[23d(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                          xdp_prog_kern.c                                                  [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[H[?2004h[?1h=[?1h=[23d[J[1;57H(B[0;7m xdp_prog_kern.c[122G    [1;124H(B[m[23d(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                           xdp_prog_kern.c                                                   [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[H[?2004h[?1h=[?1h=[23d[J[1;58H(B[0;7m  xdp_prog_kern.c[124G      [1;128H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                             xdp_prog_kern.c                                                   [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[H[?2004h[?1h=[?1h=[23d[J[1;60H(B[0;7m xdp_prog_kern.c[126G      [1;130H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                              xdp_prog_kern.c                                                      [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[H[?2004h[?1h=[?1h=[23d[J[1;61H(B[0;7m xdp_prog_kern.c[130G   [1;131H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                               xdp_prog_kern.c                                                       [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[H[?2004h[?1h=[?1h=[23d[J[1;62H(B[0;7m xdp_prog_kern.c[132G   [1;133H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                xdp_prog_kern.c                                                       [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[H[?2004h[?1h=[?1h=[23d[J[1;63H(B[0;7m  xdp_prog_kern.c[133G      [1;137H(B[m[23d(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                  xdp_prog_kern.c                                                       [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[H[?2004h[?1h=[?1h=[23d[J[1;135H(B[0;7m     [1;138H(B[m[23d(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                  xdp_prog_kern.c                                                           [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[H[?2004h[?1h=[?1h=[23d[J[1;65H(B[0;7m xdp_prog_kern.c[139G  [1;139H(B[m[23d(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark   (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[121G(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                   xdp_prog_kern.c                                                           [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark   (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[121G(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;140H(B[0;7m  [1;140H(B[m[23d(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark   (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[121G(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                   xdp_prog_kern.c                                                            [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark   (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[121G(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;66H(B[0;7m xdp_prog_kern.c[141G  [1;141H(B[m[23d(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark   (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[121G(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                    xdp_prog_kern.c                                                            [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark   (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[121G(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;142H(B[0;7m  [1;142H(B[m[23d(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark   (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[121G(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                    xdp_prog_kern.c                                                             [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark   (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[121G(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;67H(B[0;7m xdp_prog_kern.c[143G  [1;143H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                     xdp_prog_kern.c                                                             [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;144H(B[0;7m  [1;144H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                     xdp_prog_kern.c                                                              [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;68H(B[0;7m xdp_prog_kern.c[145G   [1;146H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                      xdp_prog_kern.c                                                              [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;69H(B[0;7m xdp_prog_kern.c[146G   [1;147H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                       xdp_prog_kern.c                                                               [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;70H(B[0;7m xdp_prog_kern.c[148G   [1;149H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                        xdp_prog_kern.c                                                               [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;149H(B[0;7m   [1;150H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                        xdp_prog_kern.c                                                                 [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;71H(B[0;7m xdp_prog_kern.c[151G  [1;151H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                         xdp_prog_kern.c                                                                 [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;72H(B[0;7m xdp_prog_kern.c[152G   [1;153H(B[m[23d(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                          xdp_prog_kern.c                                                                 [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;153H(B[0;7m   [1;154H(B[m[23d(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                          xdp_prog_kern.c                                                                   [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;73H(B[0;7m xdp_prog_kern.c[155G  [1;155H(B[m[23d(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                           xdp_prog_kern.c                                                                   [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;156H(B[0;7m  [1;156H(B[m[23d(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                           xdp_prog_kern.c                                                                    [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;74H(B[0;7m xdp_prog_kern.c[157G  [1;157H(B[m[23d(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                            xdp_prog_kern.c                                                                    [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;158H(B[0;7m  [1;158H(B[m[23d(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                            xdp_prog_kern.c                                                                     [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[H[?2004h[?1h=[?1h=[23d[J[1;75H(B[0;7m xdp_prog_kern.c[159G  [1;159H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket  (B[0;7mM-Q(B[m Previous[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was    (B[0;7mM-W(B[m Next[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                             xdp_prog_kern.c                                                                     [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket  (B[0;7mM-Q(B[m Previous[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was    (B[0;7mM-W(B[m Next[H[?2004h[?1h=[?1h=[23d[J[1;160H(B[0;7m  [1;160H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket  (B[0;7mM-Q(B[m Previous[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was    (B[0;7mM-W(B[m Next[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                             xdp_prog_kern.c                                                                      [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket  (B[0;7mM-Q(B[m Previous[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was    (B[0;7mM-W(B[m Next[H[?2004h[?1h=[?1h=[23d[J[1;76H(B[0;7m xdp_prog_kern.c[161G  [1;161H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket  (B[0;7mM-Q(B[m Previous[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was    (B[0;7mM-W(B[m Next[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                              xdp_prog_kern.c                                                                      [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket  (B[0;7mM-Q(B[m Previous[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was    (B[0;7mM-W(B[m Next[H[?2004h[?1h=[?1h=[23d[J[1;162H(B[0;7m  [1;162H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket  (B[0;7mM-Q(B[m Previous[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was    (B[0;7mM-W(B[m Next[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                              xdp_prog_kern.c                                                                       [3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket  (B[0;7mM-Q(B[m Previous[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was    (B[0;7mM-W(B[m Next[H[?2004h[?1h=[?1h=[23d[J[1;77H(B[0;7m xdp_prog_kern.c[163G  [1;163H(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket  (B[0;7mM-Q(B[m Previous[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was    (B[0;7mM-W(B[m Next[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                                               xdp_prog_kern.c                                                                       [3;1H(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket  (B[0;7mM-Q(B[m Previous[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was    (B[0;7mM-W(B[m Next[H[?2004h[?1h=[?1h=[23d[J[1;77H(B[0;7mxdp_prog_kern.c [162G(B[m[23d(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket  (B[0;7mM-Q(B[m Previous[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was    (B[0;7mM-W(B[m Next[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                                              xdp_prog_kern.c                                                                       [1;161H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket  (B[0;7mM-Q(B[m Previous[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was    (B[0;7mM-W(B[m Next[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                                             xdp_prog_kern.c                                                                      [1;159H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket  (B[0;7mM-Q(B[m Previous[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was    (B[0;7mM-W(B[m Next[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                                            xdp_prog_kern.c                                                                     [1;157H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                                           xdp_prog_kern.c                                                                    [1;155H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                                          xdp_prog_kern.c                                                                   [1;153H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark     (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[24;137H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                                        xdp_prog_kern.c                                                                  [1;150H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                                       xdp_prog_kern.c                                                                 [1;148H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                                      xdp_prog_kern.c                                                                [1;146H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                                     xdp_prog_kern.c                                                               [1;144H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark    (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[24;129H(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                                    xdp_prog_kern.c                                                             [1;141H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark   (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[121G(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                                   xdp_prog_kern.c                                                            [1;139H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark   (B[0;7mM-](B[m To Bracket[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[121G(B[0;7m^Q(B[m Where Was[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                                 xdp_prog_kern.c                                                           [1;136H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[23;120H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[24;120H(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                                xdp_prog_kern.c                                                          [1;134H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                               xdp_prog_kern.c                                                        [1;131H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                              xdp_prog_kern.c                                                       [1;129H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                             xdp_prog_kern.c                                                      [1;127H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[23;113H(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[24;113H(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                            xdp_prog_kern.c                                                     [1;125H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                           xdp_prog_kern.c                                                    [1;123H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                          xdp_prog_kern.c                                                   [1;121H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                         xdp_prog_kern.c                                                   [1;120H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                         xdp_prog_kern.c                                                  [1;119H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[106G(B[0;7mM-A(B[m Set Mark[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[106G(B[0;7mM-6(B[m Copy[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                        xdp_prog_kern.c                                                  [1;118H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;18H(B[0;7m^O(B[m Write Out     (B[0;7m^W(B[m Where Is[52G(B[0;7m^K(B[m Cut[23;69H(B[0;7m^T(B[m Execute[86G(B[0;7m^C(B[m Location[103G(B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;18H(B[0;7m^R(B[m Read File     (B[0;7m^\(B[m Replace[52G(B[0;7m^U(B[m Paste[24;69H(B[0;7m^J(B[m Justify[86G(B[0;7m^/(B[m Go To Line    (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                        xdp_prog_kern.c                                                 [1;117H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                       xdp_prog_kern.c                                                 [1;116H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                       xdp_prog_kern.c                                                [1;115H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                      xdp_prog_kern.c                                                [1;114H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                      xdp_prog_kern.c                                               [1;113H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                     xdp_prog_kern.c                                               [1;112H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                     xdp_prog_kern.c                                              [1;111H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;17H(B[0;7m^O(B[m Write Out    (B[0;7m^W(B[m Where Is     (B[0;7m^K(B[m Cut[23;65H(B[0;7m^T(B[m Execute[81G(B[0;7m^C(B[m Location     (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;17H(B[0;7m^R(B[m Read File    (B[0;7m^\(B[m Replace[49G(B[0;7m^U(B[m Paste[24;65H(B[0;7m^J(B[m Justify[81G(B[0;7m^/(B[m Go To Line   (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                    xdp_prog_kern.c                                              [1;110H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                    xdp_prog_kern.c                                             [1;109H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                   xdp_prog_kern.c                                             [1;108H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                   xdp_prog_kern.c                                            [1;107H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                  xdp_prog_kern.c                                            [1;106H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                  xdp_prog_kern.c                                           [1;105H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                           [1;104H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[23;16H(B[0;7m^O(B[m Write Out   (B[0;7m^W(B[m Where Is    (B[0;7m^K(B[m Cut[23;61H(B[0;7m^T(B[m Execute     (B[0;7m^C(B[m Location    (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[24;16H(B[0;7m^R(B[m Read File   (B[0;7m^\(B[m Replace     (B[0;7m^U(B[m Paste[61G(B[0;7m^J(B[m Justify     (B[0;7m^/(B[m Go To Line  (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;24r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [1;103H(B[m[3d(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[4d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[5d{[6;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[7;9H// void *data     = (void *)(long)ctx->data;[8;9H(B[0m[32mstruct[39m(B[m datarec *rec;[9;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[11;9H/* Lookup in kernel BPF-side return pointer to actual data record */[12;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[13;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[14;9H[1K * check isn't performed here. Even-though this is a static array where[15;9H[1K * we know key lookup XDP_PASS always will succeed.[16;9H[1K */[17;9H[33mif[39m(B[m (!rec)[18d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[23d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[23;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K */[20;9H[39m(B[mlock_xadd(&rec->rx_packets, 1);[21;9H(B[0;1m[34m/* Assignment#1: Add byte counters[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K * - Hint look at struct xdp_md *ctx (copied below)[20;9H[1K *[21d[1K * Assignment#3: Avoid the atomic operation[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K * - Hint there is a map type named BPF_MAP_TYPE_PERCPU_ARRAY[20;9H[1K */[21d[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H[35mreturn[39m(B[m (B[0;1m[31mXDP_PASS[39m(B[m;[20d}[21d[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[21d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34m *[20d * User return codes for XDP prog type.[21d * A valid XDP program must return one of these defined values. All other[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34m * return codes are reserved for future use. Unknown return codes will[20d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[21d *[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34menum xdp_action {[20;8H[1K XDP_ABORTED = 0,[21;8H[1K XDP_DROP,[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;8H(B[0;1m[34m[1K XDP_PASS,[20;8H[1K XDP_TX,[21;8H[1K XDP_REDIRECT,[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34m};[21d * user accessible metadata for XDP packet hook[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34m * new fields must be added to the end of this structure[20d *[21dstruct xdp_md {[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;8H(B[0;1m[34m[1K // (Note: type __u32 is NOT the real-type)[20;8H[1K __u32 data;[21;8H[1K __u32 data_end;[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;8H(B[0;1m[34m[1K __u32 data_meta;[20;8H[1K // Below access go through struct xdp_rxq_info[21;8H[1K __u32 ingress_ifindex; // rxq->dev->ifindex[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;8H(B[0;1m[34m[1K __u32 rx_queue_index;  // rxq->queue_index[20d};[21d*/[39m(B[m[?25l[?12l[?25h7[2;22r8[22d
[1;24r[21;1H[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[18d[?25l[?12l[?25h[15d[?25l[?12l[?25h[12d[?25l[?12l[?25h[9d[?25l[?12l[?25h[6d[?25l[?12l[?25h[3d[?25l[?12l[?25h[6d[?25l[?12l[?25h[9d[?25l[?12l[?25h[6d[?25l[?12l[?25h[3d[?25l[?12l[?25h[2;21r[2;1H[2T[1;24r[2;1H(B[0;1m[34menum xdp_action {[3;8H[1K XDP_ABORTED = 0,[A[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H(B[0;1m[34m * return codes are reserved for future use. Unknown return codes will[3d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[4d *[2d[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H(B[0;1m[34m *[3d * User return codes for XDP prog type.[4d * A valid XDP program must return one of these defined values. All other[2d[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[4d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[2d[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;9H[35mreturn[39m(B[m (B[0;1m[31mXDP_PASS[39m(B[m;[3d}[A[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;9H(B[0;1m[34m[1K * - Hint there is a map type named BPF_MAP_TYPE_PERCPU_ARRAY[3;9H[1K */[A[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;9H(B[0;1m[34m[1K * - Hint look at struct xdp_md *ctx (copied below)[3;9H[1K *[4d[1K * Assignment#3: Avoid the atomic operation[2d[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;9H(B[0;1m[34m[1K */[3;9H[39m(B[mlock_xadd(&rec->rx_packets, 1);[4;9H(B[0;1m[34m/* Assignment#1: Add byte counters[2d[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[3;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[4;9H[1K * use an atomic operation.[2d[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;9H(B[0;1m[34m[1K */[3;9H[33mif[39m(B[m (!rec)[4d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[2d[?25l[?12l[?25h7[2;22r8[3T[1;24r[2;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[3;9H[1K * check isn't performed here. Even-though this is a static array where[4;9H[1K * we know key lookup XDP_PASS always will succeed.[2d[39m(B[m[?25l[?12l[?25h[5d[?25l[?12l[?25h[8d[?25l[?12l[?25h[11d[?25l[?12l[?25h[14d[?25l[?12l[?25h[17d[?25l[?12l[?25h[20d[?25l[?12l[?25h[2;22r[22;1H[2S[1;24r[21;1H[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[20;1H(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[21d *[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34m * User return codes for XDP prog type.[20d * A valid XDP program must return one of these defined values. All other[21d * return codes are reserved for future use. Unknown return codes will[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34m * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[20d *[21denum xdp_action {[39m(B[m[?25l[?12l[?25h[18d[?25l[?12l[?25h[15d[?25l[?12l[?25h[12d[?25l[?12l[?25h[9d[?25l[?12l[?25h[6d[?25l[?12l[?25h[3d[?25l[?12l[?25h[2;21r[2;1H[2T[1;24r[2;9H(B[0;1m[34m[1K */[3;9H[39m(B[mlock_xadd(&rec->rx_packets, 1);[A[?25l[?12l[?25h7[2;21r8[3T[1;24r[3;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[4;9H[1K * use an atomic operation.[2d[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;9H(B[0;1m[34m[1K */[3;9H[33mif[39m(B[m (!rec)[4d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[2d[?25l[?12l[?25h7[2;22r8[3T[1;24r[2;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[3;9H[1K * check isn't performed here. Even-though this is a static array where[4;9H[1K * we know key lookup XDP_PASS always will succeed.[2d[39m(B[m[?25l[?12l[?25h7[2;22r8[3T[1;24r[3;9H(B[0;1m[34m/* Lookup in kernel BPF-side return pointer to actual data record */[4;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[2d[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;9H(B[0;1m[34m// void *data     = (void *)(long)ctx->data;[3;9H(B[0m[32mstruct[39m(B[m datarec *rec;[4;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[2d[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[3d{[4;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[2d[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H(B[0;1m[36m#endif[4d[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[2d[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H(B[0;1m[34m */[3d[36m#ifndef lock_xadd[4d#define[39m(B[m lock_xadd(ptr, val)     (([32mvoid[39m(B[m) __sync_fetch_and_add(ptr, val))[2d[?25l[?12l[?25h7[2;21r8[3T[1;24r[3;1H(B[0;1m[34m/* LLVM maps __sync_fetch_and_add() as a built-in function to the BPF atomic add[4d * instruction (that is BPF_STX | BPF_XADD | BPF_W for word sizes)[2d[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;9H__type(value, [32mstruct[39m(B[m datarec);[3;9H__uint(max_entries, (B[0;1m[31mXDP_ACTION_MAX[39m(B[m);[4d} xdp_stats_map (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m".maps"[39m(B[m);[2d[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H[32mstruct[39m(B[m {[3d__uint(type, (B[0;1m[31mBPF_MAP_TYPE_ARRAY[39m(B[m);[4;9H__type(key, __u32);[2d[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H(B[0;1m[34m * - Here an array with XDP_ACTION_MAX (max_)entries are created.[3d * - The idea is to keep stats per (enum) xdp_action[4d */[2d[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H(B[0;1m[36m#include[39m(B[m (B[0;1m[33m"common_kern_user.h"[39m(B[m (B[0;1m[34m/* defines: struct datarec; */[4d/* Lesson#1: See how a map is defined.[2d[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H(B[0;1m[36m#include[33m <linux/bpf.h>[3d[36m#include[33m <bpf/bpf_helpers.h>[A[39m(B[m[?25l[?12l[?25h7[2;21r8M[1;24r[2;1H(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[39m(B[m[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[5d[?25l[?12l[?25h[8d[?25l[?12l[?25h[11d[?25l[?12l[?25h[14d[?25l[?12l[?25h[17d[?25l[?12l[?25h[20d[?25l[?12l[?25h[2;22r[22;1H[2S[1;24r[20;1H(B[0;1m[36m#ifndef lock_xadd[21d#define[39m(B[m lock_xadd(ptr, val)     (([32mvoid[39m(B[m) __sync_fetch_and_add(ptr, val))[?25l[?12l[?25h[18d[?25l[?12l[?25h[15d[?25l[?12l[?25h[12d[?25l[?12l[?25h[15d[?25l[?12l[?25h[18d[?25l[?12l[?25h[15d[?25l[?12l[?25h[12d[?25l[?12l[?25h[9d[?25l[?12l[?25h[6d[?25l[?12l[?25h[3d[?25l[?12l[?25h[2;21r[2;1H[2T[1;24r[2;1H(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d[36m#include[33m <linux/bpf.h>[A[39m(B[m[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[5d[?25l[?12l[?25h[8d[?25l[?12l[?25h[11d[?25l[?12l[?25h[14d[?25l[?12l[?25h[17d[?25l[?12l[?25h[20d[?25l[?12l[?25h[2;22r[22;1H[2S[1;24r[20;1H(B[0;1m[36m#ifndef lock_xadd[21d#define[39m(B[m lock_xadd(ptr, val)     (([32mvoid[39m(B[m) __sync_fetch_and_add(ptr, val))[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[36m#endif[21d[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[20d{[21;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m// void *data     = (void *)(long)ctx->data;[20;9H(B[0m[32mstruct[39m(B[m datarec *rec;[21;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[20;9H(B[0;1m[34m/* Lookup in kernel BPF-side return pointer to actual data record */[21;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[20;9H[1K * check isn't performed here. Even-though this is a static array where[21;9H[1K * we know key lookup XDP_PASS always will succeed.[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K */[20;9H[33mif[39m(B[m (!rec)[21d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K */[20;9H[39m(B[mlock_xadd(&rec->rx_packets, 1);[21;9H(B[0;1m[34m/* Assignment#1: Add byte counters[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K * - Hint look at struct xdp_md *ctx (copied below)[20;9H[1K *[21d[1K * Assignment#3: Avoid the atomic operation[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K * - Hint there is a map type named BPF_MAP_TYPE_PERCPU_ARRAY[20;9H[1K */[21d[39m(B[m[?25l[?12l[?25h[18d[?25l[?12l[?25h[15d[?25l[?12l[?25h[12d[?25l[?12l[?25h[9d[?25l[?12l[?25h[6d[?25l[?12l[?25h[3d[?25l[?12l[?25h[2;21r[2;1H[2T[1;24r[2;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[3;9H// void *data     = (void *)(long)ctx->data;[4;9H(B[0m[32mstruct[39m(B[m datarec *rec;[2d[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[3d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[4d{[2d[?25l[?12l[?25h[5d[?25l[?12l[?25h[8d[?25l[?12l[?25h[11d[?25l[?12l[?25h[14d[?25l[?12l[?25h[17d[?25l[?12l[?25h[20d[?25l[?12l[?25h[2;22r[22;1H[2S[1;24r[20;9Hlock_xadd(&rec->rx_packets, 1);[21;9H(B[0;1m[34m/* Assignment#1: Add byte counters[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K * - Hint look at struct xdp_md *ctx (copied below)[20;9H[1K *[21d[1K * Assignment#3: Avoid the atomic operation[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K * - Hint there is a map type named BPF_MAP_TYPE_PERCPU_ARRAY[20;9H[1K */[21d[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H[35mreturn[39m(B[m (B[0;1m[31mXDP_PASS[39m(B[m;[20d}[21d[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[21d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34m *[20d * User return codes for XDP prog type.[21d * A valid XDP program must return one of these defined values. All other[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34m * return codes are reserved for future use. Unknown return codes will[20d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[21d *[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34menum xdp_action {[20;8H[1K XDP_ABORTED = 0,[21;8H[1K XDP_DROP,[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;8H(B[0;1m[34m[1K XDP_PASS,[20;8H[1K XDP_TX,[21;8H[1K XDP_REDIRECT,[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34m};[21d * user accessible metadata for XDP packet hook[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34m * new fields must be added to the end of this structure[20d *[21dstruct xdp_md {[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;8H(B[0;1m[34m[1K // (Note: type __u32 is NOT the real-type)[20;8H[1K __u32 data;[21;8H[1K __u32 data_end;[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;8H(B[0;1m[34m[1K __u32 data_meta;[20;8H[1K // Below access go through struct xdp_rxq_info[21;8H[1K __u32 ingress_ifindex; // rxq->dev->ifindex[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;8H(B[0;1m[34m[1K __u32 rx_queue_index;  // rxq->queue_index[20d};[21d*/[39m(B[m[?25l[?12l[?25h7[2;22r8[22d
[1;24r[21;1H[?25l[?12l[?25h[?25l[23d[J[24d[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?2004l[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ nano common_kern_user.h 
[?2004l[?2004h[?1049h[22;0;0t[1;24r(B[m[4l[?7h[39;49m[?1h=[?1h=[?25l[39;49m(B[m[H[2J[22;46H(B[0;7m[ Reading... ](B[m[22;44H(B[0;7m[ Read 17 lines ](B[m[H(B[0;7m  GNU nano 7.2                               common_kern_user.h                                         [1;103H(B[m[23d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[23;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[2d(B[0;1m[34m/* This common_kern_user.h is used by kernel side BPF-progs and[3d * userspace programs, for sharing common struct's and DEFINEs.[4d */[5d[36m#ifndef __COMMON_KERN_USER_H[6d#define[39m(B[m (B[0;1m[31m__COMMON_KERN_USER_H[8d[34m/* This is the data record stored in the map */[9d(B[0m[32mstruct[39m(B[m datarec {[10;9H__u64 rx_packets;[11;9H(B[0;1m[34m/* Assignment#1: Add byte counters */[12d[39m(B[m};[14d(B[0;1m[36m#ifndef XDP_ACTION_MAX[15d#define[39m(B[m (B[0;1m[31mXDP_ACTION_MAX[39m(B[m ((B[0;1m[31mXDP_REDIRECT[39m(B[m + 1)[16d(B[0;1m[36m#endif[18d#endif[39m(B[m (B[0;1m[34m/* __COMMON_KERN_USER_H */[2d[39m(B[m[?12l[?25h[?25l[?12l[?25h[3d[?25l[?12l[?25h[4d[?25l[?12l[?25h[5d[?25l[?12l[?25h[6d[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h [?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[22d[K[?12l[?25h[6;17H[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[7d[?25l[?12l[?25h[8;23H[?25l[?12l[?25h[9;17H[?25l[?12l[?25h[10;23H[?25l[?12l[?25ht[?25l[?12l[?25hs[?25l[?12l[?25h;[?25l[1;65H(B[0;7m*[103G(B[m[11;22r[11;1HM[1;24r[11;1H[?12l[?25h[?25l[?12l[?25h[8G[42m[1K [49m(B[m[?25l[10;22r[10;1HM[1;24r[10;9H__u64 rx_packets;[12d[K[?12l[?25h[?25l[12;22r[22;1H
[1;24r[11;26H[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h;[K[?25l[?12l[?25h;[K[?25l[?12l[?25h;[K[?25l[?12l[?25h;[K[?25l[?12l[?25h;[K[?25l[?12l[?25h;[K[?25l[?12l[?25h;[K[?25l[?12l[?25hb;[?25l[?12l[?25hy;[?25l[?12l[?25ht;[?25l[?12l[?25he;[?25l[?12l[?25hs;[?25l[22;46H(B[0;7m[ Writing... ](B[m[1;65H(B[0;7m [103G(B[m[22;44H(B[0;7m[ Wrote 18 lines ](B[m[?12l[?25h[11;23H[?25l[22;44H  (B[0;7m[ Writing... ](B[m[K[1;103H[22;44H(B[0;7m[ Wrote 18 lines ](B[m[?12l[?25h[11;23H[?25l[22d[J[24d[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?2004l[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ nano common_kern_user.h 
[?2004l[?2004h[?1049h[22;0;0t[1;24r(B[m[4l[?7h[39;49m[?1h=[?1h=[?25l[39;49m(B[m[H[2J[22;46H(B[0;7m[ Reading... ](B[m[22;44H(B[0;7m[ Read 18 lines ](B[m[H(B[0;7m  GNU nano 7.2                               common_kern_user.h                                         [1;103H(B[m[23d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[23;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[2d(B[0;1m[34m/* This common_kern_user.h is used by kernel side BPF-progs and[3d * userspace programs, for sharing common struct's and DEFINEs.[4d */[5d[36m#ifndef __COMMON_KERN_USER_H[6d#define[39m(B[m (B[0;1m[31m__COMMON_KERN_USER_H[8d[34m/* This is the data record stored in the map */[9d(B[0m[32mstruct[39m(B[m datarec {[10;9H__u64 rx_packets;[11;9H__u64 rx_bytes;[12;9H(B[0;1m[34m/* Assignment#1: Add byte counters */[13d[39m(B[m};[15d(B[0;1m[36m#ifndef XDP_ACTION_MAX[16d#define[39m(B[m (B[0;1m[31mXDP_ACTION_MAX[39m(B[m ((B[0;1m[31mXDP_REDIRECT[39m(B[m + 1)[17d(B[0;1m[36m#endif[19d#endif[39m(B[m (B[0;1m[34m/* __COMMON_KERN_USER_H */[2d[39m(B[m[?12l[?25h[?25l[22d[J[24d[?12l[?25h[24;1H[?1049l[23;0;0t[?1l>[?2004l[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ nano common_kern_user.h [4Pxdp_prog_kern.cls[Knano xdp_prog_kern.c
[?2004l[?2004h[?1049h[22;0;0t[1;24r(B[m[4l[?7h[39;49m[?1h=[?1h=[?25l[39;49m(B[m[H[2J[22;46H(B[0;7m[ Reading... ](B[m[22;44H(B[0;7m[ Read 85 lines ](B[m[H(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [1;103H(B[m[23d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[23;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[24d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[2d(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d[36m#include[33m <linux/bpf.h>[4d[36m#include[33m <bpf/bpf_helpers.h>[6d[36m#include[39m(B[m (B[0;1m[33m"common_kern_user.h"[39m(B[m (B[0;1m[34m/* defines: struct datarec; */[8d/* Lesson#1: See how a map is defined.[9d * - Here an array with XDP_ACTION_MAX (max_)entries are created.[10d * - The idea is to keep stats per (enum) xdp_action[11d */[12d(B[0m[32mstruct[39m(B[m {[13d__uint(type, (B[0;1m[31mBPF_MAP_TYPE_ARRAY[39m(B[m);[14;9H__type(key, __u32);[15;9H__type(value, [32mstruct[39m(B[m datarec);[16;9H__uint(max_entries, (B[0;1m[31mXDP_ACTION_MAX[39m(B[m);[17d} xdp_stats_map (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m".maps"[39m(B[m);[19d(B[0;1m[34m/* LLVM maps __sync_fetch_and_add() as a built-in function to the BPF atomic add[20d * instruction (that is BPF_STX | BPF_XADD | BPF_W for word sizes)[21d */[2d[39m(B[m[?12l[?25h[?25l[?12l[?25h[5d[?25l[?12l[?25h[8d[?25l[?12l[?25h[11d[?25l[?12l[?25h[14d[?25l[?12l[?25h[17d[?25l[?12l[?25h[20d[?25l[22d[K[?12l[?25h[17d[?25l[?12l[?25h[14d[?25l[?12l[?25h[17d[?25l[?12l[?25h[20d[?25l[?12l[?25h[2;22r[22;1H[2S[1;24r[20;1H(B[0;1m[36m#ifndef lock_xadd[21d#define[39m(B[m lock_xadd(ptr, val)     (([32mvoid[39m(B[m) __sync_fetch_and_add(ptr, val))[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[36m#endif[21d[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[20d{[21;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m// void *data     = (void *)(long)ctx->data;[20;9H(B[0m[32mstruct[39m(B[m datarec *rec;[21;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[20;9H(B[0;1m[34m/* Lookup in kernel BPF-side return pointer to actual data record */[21;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[20;9H[1K * check isn't performed here. Even-though this is a static array where[21;9H[1K * we know key lookup XDP_PASS always will succeed.[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K */[20;9H[33mif[39m(B[m (!rec)[21d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K */[20;9H[39m(B[mlock_xadd(&rec->rx_packets, 1);[21;9H(B[0;1m[34m/* Assignment#1: Add byte counters[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K * - Hint look at struct xdp_md *ctx (copied below)[20;9H[1K *[21d[1K * Assignment#3: Avoid the atomic operation[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K * - Hint there is a map type named BPF_MAP_TYPE_PERCPU_ARRAY[20;9H[1K */[21d[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H[35mreturn[39m(B[m (B[0;1m[31mXDP_PASS[39m(B[m;[20d}[21d[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[21d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34m *[20d * User return codes for XDP prog type.[21d * A valid XDP program must return one of these defined values. All other[39m(B[m[?25l[?12l[?25h[18d[?25l[?12l[?25h[15d[?25l[?12l[?25h[12d[?25l[?12l[?25h[9d[?25l[?12l[?25h[6d[?25l[?12l[?25h[3d[?25l[?12l[?25h[2;21r[2;1H[2T[1;24r[2;17H[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[?25l[?12l[?25h7[2;22r8[3T[1;24r[2;9H(B[0;1m[34m[1K * we know key lookup XDP_PASS always will succeed.[3;9H[1K */[4;9H[33mif[39m(B[m (!rec)[2d[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;9Hrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[3;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[4;9H[1K * check isn't performed here. Even-though this is a static array where[2d[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[4;9H/* Lookup in kernel BPF-side return pointer to actual data record */[2d[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[3;9H// void *data     = (void *)(long)ctx->data;[4;9H(B[0m[32mstruct[39m(B[m datarec *rec;[2d[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[3d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[4d{[2d[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H(B[0;1m[36m#define[39m(B[m lock_xadd(ptr, val)     (([32mvoid[39m(B[m) __sync_fetch_and_add(ptr, val))[3d(B[0;1m[36m#endif[A[39m(B[m[?25l[?12l[?25h7[2;21r8[3T[1;24r[2;1H(B[0;1m[34m * instruction (that is BPF_STX | BPF_XADD | BPF_W for word sizes)[3d */[4d[36m#ifndef lock_xadd[2d[39m(B[m[?25l[?12l[?25h[5d[?25l[?12l[?25h[8d[?25l[?12l[?25h[11d[?25l[?12l[?25h[14d[?25l[?12l[?25h[17d[?25l[?12l[?25h[20d[?25l[?12l[?25h[2;22r[22;1H[2S[1;24r[20;9H(B[0;1m[33mif[39m(B[m (!rec)[21d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[20;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[21;9H[1K * use an atomic operation.[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K */[20;9H[39m(B[mlock_xadd(&rec->rx_packets, 1);[21;9H(B[0;1m[34m/* Assignment#1: Add byte counters[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K * - Hint look at struct xdp_md *ctx (copied below)[20;9H[1K *[21d[1K * Assignment#3: Avoid the atomic operation[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H(B[0;1m[34m[1K * - Hint there is a map type named BPF_MAP_TYPE_PERCPU_ARRAY[20;9H[1K */[21d[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;9H[35mreturn[39m(B[m (B[0;1m[31mXDP_PASS[39m(B[m;[20d}[21d[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[21d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34m *[20d * User return codes for XDP prog type.[21d * A valid XDP program must return one of these defined values. All other[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34m * return codes are reserved for future use. Unknown return codes will[20d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[21d *[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34menum xdp_action {[20;8H[1K XDP_ABORTED = 0,[21;8H[1K XDP_DROP,[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;8H(B[0;1m[34m[1K XDP_PASS,[20;8H[1K XDP_TX,[21;8H[1K XDP_REDIRECT,[39m(B[m[?25l[?12l[?25h7[2;22r8[22d[3S[1;24r[19;1H(B[0;1m[34m};[21d * user accessible metadata for XDP packet hook[39m(B[m[24;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;25r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J[?2004h[?1h=[?1h=(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [1;103H(B[m[2d}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[24d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[24;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[25d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[25;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;26r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[24d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[24;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[24d[J[1;103H[23d(B[0;1m[34m *[25d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[25;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[26d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[26;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;27r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[25d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[25;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[25d[J[1;103H[24d(B[0;1m[34mstruct xdp_md {[26d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[26;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[27d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[27;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;28r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[26d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[26;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[26d[J[1;103H[25;8H(B[0;1m[34m[1K // (Note: type __u32 is NOT the real-type)[27d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[27;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[28d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[28;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;29r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[27d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[27;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[27d[J[1;103H[26;8H(B[0;1m[34m[1K __u32 data;[28d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[28;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[29d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[29;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;30r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[28d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[28;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[28d[J[1;103H[27;8H(B[0;1m[34m[1K __u32 data_end;[29d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[29;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[30d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[30;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;31r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[27;8H[1K __u32 data_end;[29d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[29;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[29d[J[1;103H[28;8H(B[0;1m[34m[1K __u32 data_meta;[30d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[30;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[31d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[31;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;32r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[27;8H[1K __u32 data_end;[28;8H[1K __u32 data_meta;[30d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[30;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[30d[J[1;103H[29;8H(B[0;1m[34m[1K // Below access go through struct xdp_rxq_info[31d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[31;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[32d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[32;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;33r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[27;8H[1K __u32 data_end;[28;8H[1K __u32 data_meta;[29;8H[1K // Below access go through struct xdp_rxq_info[31d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[31;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[31d[J[1;103H[30;8H(B[0;1m[34m[1K __u32 ingress_ifindex; // rxq->dev->ifindex[32d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[32;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[33d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[33;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;34r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[27;8H[1K __u32 data_end;[28;8H[1K __u32 data_meta;[29;8H[1K // Below access go through struct xdp_rxq_info[30;8H[1K __u32 ingress_ifindex; // rxq->dev->ifindex[32d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[32;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[32d[J[1;103H[31;8H(B[0;1m[34m[1K __u32 rx_queue_index;  // rxq->queue_index[33d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[33;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[34d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[34;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;35r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[27;8H[1K __u32 data_end;[28;8H[1K __u32 data_meta;[29;8H[1K // Below access go through struct xdp_rxq_info[30;8H[1K __u32 ingress_ifindex; // rxq->dev->ifindex[31;8H[1K __u32 rx_queue_index;  // rxq->queue_index[33d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[33;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[33d[J[1;103H[32d(B[0;1m[34m};[34d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[34;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[35d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[35;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;36r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[27;8H[1K __u32 data_end;[28;8H[1K __u32 data_meta;[29;8H[1K // Below access go through struct xdp_rxq_info[30;8H[1K __u32 ingress_ifindex; // rxq->dev->ifindex[31;8H[1K __u32 rx_queue_index;  // rxq->queue_index[32d};[34d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[34;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[34d[J[1;103H[33d(B[0;1m[34m*/[35d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[35;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[36d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[36;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;37r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[27;8H[1K __u32 data_end;[28;8H[1K __u32 data_meta;[29;8H[1K // Below access go through struct xdp_rxq_info[30;8H[1K __u32 ingress_ifindex; // rxq->dev->ifindex[31;8H[1K __u32 rx_queue_index;  // rxq->queue_index[32d};[33d*/[35d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[35;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[35d[J[1;103H[36d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[36;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[37d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[37;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;38r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[27;8H[1K __u32 data_end;[28;8H[1K __u32 data_meta;[29;8H[1K // Below access go through struct xdp_rxq_info[30;8H[1K __u32 ingress_ifindex; // rxq->dev->ifindex[31;8H[1K __u32 rx_queue_index;  // rxq->queue_index[32d};[33d*/[36d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[36;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[36d[J[1;103H[37d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[37;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[38d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[38;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;39r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[27;8H[1K __u32 data_end;[28;8H[1K __u32 data_meta;[29;8H[1K // Below access go through struct xdp_rxq_info[30;8H[1K __u32 ingress_ifindex; // rxq->dev->ifindex[31;8H[1K __u32 rx_queue_index;  // rxq->queue_index[32d};[33d*/[37d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[37;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[37d[J[1;103H[38d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[38;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[39d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[39;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;40r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[27;8H[1K __u32 data_end;[28;8H[1K __u32 data_meta;[29;8H[1K // Below access go through struct xdp_rxq_info[30;8H[1K __u32 ingress_ifindex; // rxq->dev->ifindex[31;8H[1K __u32 rx_queue_index;  // rxq->queue_index[32d};[33d*/[38d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[38;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[38d[J[1;103H[39d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[39;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[40d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[40;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;41r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[27;8H[1K __u32 data_end;[28;8H[1K __u32 data_meta;[29;8H[1K // Below access go through struct xdp_rxq_info[30;8H[1K __u32 ingress_ifindex; // rxq->dev->ifindex[31;8H[1K __u32 rx_queue_index;  // rxq->queue_index[32d};[33d*/[39d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[39;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[39d[J[1;103H[40d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[40;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[41d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[41;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;42r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[27;8H[1K __u32 data_end;[28;8H[1K __u32 data_meta;[29;8H[1K // Below access go through struct xdp_rxq_info[30;8H[1K __u32 ingress_ifindex; // rxq->dev->ifindex[31;8H[1K __u32 rx_queue_index;  // rxq->queue_index[32d};[33d*/[40d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[40;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[40d[J[1;103H[41d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[41;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[42d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[42;1H[?1049l[23;0;0t[?1l>[?1049h[22;0;0t[1;43r[?12l[?25h[39;49m]104(B[m[4l[?7h[H[2J(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [2;1H(B[m}[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[7d *[8d * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[13denum xdp_action {[14;8H[1K XDP_ABORTED = 0,[15;8H[1K XDP_DROP,[16;8H[1K XDP_PASS,[17;8H[1K XDP_TX,[18;8H[1K XDP_REDIRECT,[19d};[21d * user accessible metadata for XDP packet hook[22d * new fields must be added to the end of this structure[23d *[24dstruct xdp_md {[25;8H[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[27;8H[1K __u32 data_end;[28;8H[1K __u32 data_meta;[29;8H[1K // Below access go through struct xdp_rxq_info[30;8H[1K __u32 ingress_ifindex; // rxq->dev->ifindex[31;8H[1K __u32 rx_queue_index;  // rxq->queue_index[32d};[33d*/[41d[39m(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[41;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[H[?2004h[?1h=[?1h=[41d[J[1;103H[42d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[42;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[43d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?25l[?12l[?25h[21d[?25l[?12l[?25h[?25l[?12l[?25h[16d[?25l[?12l[?25h[11d[?25l[?12l[?25h[6d[?25l[?12l[?25h[2;41r[2;1HM[1;43r[2;9H[35mreturn[39m(B[m (B[0;1m[31mXDP_PASS[39m(B[m;[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;9H(B[0;1m[34m[1K *[3d[1K * Assignment#3: Avoid the atomic operation[4;9H[1K * - Hint there is a map type named BPF_MAP_TYPE_PERCPU_ARRAY[5;9H[1K */[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H(B[0;1m[34m[1K * use an atomic operation.[3;9H[1K */[4;9H[39m(B[mlock_xadd(&rec->rx_packets, 1);[5;9H(B[0;1m[34m/* Assignment#1: Add byte counters[6;9H[1K * - Hint look at struct xdp_md *ctx (copied below)[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H(B[0;1m[34m[1K */[3;9H[33mif[39m(B[m (!rec)[4d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[6;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[2d[39m(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;9H(B[0;1m[34m/* Lookup in kernel BPF-side return pointer to actual data record */[3;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[4;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[5;9H[1K * check isn't performed here. Even-though this is a static array where[6;9H[1K * we know key lookup XDP_PASS always will succeed.[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[3;9H// void *data     = (void *)(long)ctx->data;[4;9H(B[0m[32mstruct[39m(B[m datarec *rec;[5;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[36m#endif[4d[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[5d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[6d{[2d[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H(B[0;1m[34m/* LLVM maps __sync_fetch_and_add() as a built-in function to the BPF atomic add[3d * instruction (that is BPF_STX | BPF_XADD | BPF_W for word sizes)[4d */[5d[36m#ifndef lock_xadd[6d#define[39m(B[m lock_xadd(ptr, val)     (([32mvoid[39m(B[m) __sync_fetch_and_add(ptr, val))[2d[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;9H__type(key, __u32);[3;9H__type(value, [32mstruct[39m(B[m datarec);[4;9H__uint(max_entries, (B[0;1m[31mXDP_ACTION_MAX[39m(B[m);[5d} xdp_stats_map (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m".maps"[39m(B[m);[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[34m * - Here an array with XDP_ACTION_MAX (max_)entries are created.[3d * - The idea is to keep stats per (enum) xdp_action[4d */[5d(B[0m[32mstruct[39m(B[m {[6d__uint(type, (B[0;1m[31mBPF_MAP_TYPE_ARRAY[39m(B[m);[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[36m#include[33m <bpf/bpf_helpers.h>[4d[36m#include[39m(B[m (B[0;1m[33m"common_kern_user.h"[39m(B[m (B[0;1m[34m/* defines: struct datarec; */[6d/* Lesson#1: See how a map is defined.[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[2T[1;43r[2;1H(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d[36m#include[33m <linux/bpf.h>[A[39m(B[m[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[7d[?25l[?12l[?25h[12d[?25l[?12l[?25h[17d[?25l[?12l[?25h[22d[?25l[?12l[?25h[27d[?25l[?12l[?25h[32d[?25l[?12l[?25h[37d[?25l[?12l[?25h[2;41r[41;1H[2S[1;43r[39;17H[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[37;9H[1K * use an atomic operation.[38;9H[1K */[39;9H[39m(B[mlock_xadd(&rec->rx_packets, 1);[40;9H(B[0;1m[34m/* Assignment#1: Add byte counters[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H(B[0;1m[34m[1K * - Hint look at struct xdp_md *ctx (copied below)[37;9H[1K *[38d[1K * Assignment#3: Avoid the atomic operation[39;9H[1K * - Hint there is a map type named BPF_MAP_TYPE_PERCPU_ARRAY[40;9H[1K */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;9H[35mreturn[39m(B[m (B[0;1m[31mXDP_PASS[39m(B[m;[38d}[40d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;1H(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[38d *[39d * User return codes for XDP prog type.[40d * A valid XDP program must return one of these defined values. All other[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;1m[34m * return codes are reserved for future use. Unknown return codes will[37d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[38d *[39denum xdp_action {[40;8H[1K XDP_ABORTED = 0,[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;8H(B[0;1m[34m[1K XDP_DROP,[37;8H[1K XDP_PASS,[38;8H[1K XDP_TX,[39;8H[1K XDP_REDIRECT,[40d};[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;1H(B[0;1m[34m * user accessible metadata for XDP packet hook[38d * new fields must be added to the end of this structure[39d *[40dstruct xdp_md {[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;8H(B[0;1m[34m[1K // (Note: type __u32 is NOT the real-type)[37;8H[1K __u32 data;[38;8H[1K __u32 data_end;[39;8H[1K __u32 data_meta;[40;8H[1K // Below access go through struct xdp_rxq_info[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;8H(B[0;1m[34m[1K __u32 ingress_ifindex; // rxq->dev->ifindex[37;8H[1K __u32 rx_queue_index;  // rxq->queue_index[38d};[39d*/[40d[39m(B[m[?25l[?12l[?25h[35d[?25l[?12l[?25h[30d[?25l[?12l[?25h[25d[?25l[?12l[?25h[20d[?25l[?12l[?25h[15d[?25l[?12l[?25h[10d[?25l[?12l[?25h[5d[?25l[?12l[?25h[2;40r[2;1H[2T[1;43r[2;9H(B[0;1m[34m/* Assignment#1: Add byte counters[3;9H[1K * - Hint look at struct xdp_md *ctx (copied below)[A[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[4;9H[1K * use an atomic operation.[5;9H[1K */[6;9H[39m(B[mlock_xadd(&rec->rx_packets, 1);[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H(B[0;1m[34m[1K * check isn't performed here. Even-though this is a static array where[3;9H[1K * we know key lookup XDP_PASS always will succeed.[4;9H[1K */[5;9H[33mif[39m(B[m (!rec)[6d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[4;9H/* Lookup in kernel BPF-side return pointer to actual data record */[5;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[6;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[3d{[4;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[5;9H// void *data     = (void *)(long)ctx->data;[6;9H(B[0m[32mstruct[39m(B[m datarec *rec;[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[36m#ifndef lock_xadd[3d#define[39m(B[m lock_xadd(ptr, val)     (([32mvoid[39m(B[m) __sync_fetch_and_add(ptr, val))[4d(B[0;1m[36m#endif[6d[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[2d[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H} xdp_stats_map (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m".maps"[39m(B[m);[4d(B[0;1m[34m/* LLVM maps __sync_fetch_and_add() as a built-in function to the BPF atomic add[5d * instruction (that is BPF_STX | BPF_XADD | BPF_W for word sizes)[6d */[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H[32mstruct[39m(B[m {[3d__uint(type, (B[0;1m[31mBPF_MAP_TYPE_ARRAY[39m(B[m);[4;9H__type(key, __u32);[5;9H__type(value, [32mstruct[39m(B[m datarec);[6;9H__uint(max_entries, (B[0;1m[31mXDP_ACTION_MAX[39m(B[m);[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H(B[0;1m[34m/* Lesson#1: See how a map is defined.[4d * - Here an array with XDP_ACTION_MAX (max_)entries are created.[5d * - The idea is to keep stats per (enum) xdp_action[6d */[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d[36m#include[33m <linux/bpf.h>[4d[36m#include[33m <bpf/bpf_helpers.h>[6d[36m#include[39m(B[m (B[0;1m[33m"common_kern_user.h"[39m(B[m (B[0;1m[34m/* defines: struct datarec; */[2d[39m(B[m[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[7d[?25l[?12l[?25h[12d[?25l[?12l[?25h[17d[?25l[?12l[?25h[22d[?25l[?12l[?25h[27d[?25l[?12l[?25h[32d[?25l[?12l[?25h[37d[?25l[?12l[?25h[2;41r[41;1H[2S[1;43r[39;17H[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[37;9H[1K * use an atomic operation.[38;9H[1K */[39;9H[39m(B[mlock_xadd(&rec->rx_packets, 1);[40;9H(B[0;1m[34m/* Assignment#1: Add byte counters[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H(B[0;1m[34m[1K * - Hint look at struct xdp_md *ctx (copied below)[37;9H[1K *[38d[1K * Assignment#3: Avoid the atomic operation[39;9H[1K * - Hint there is a map type named BPF_MAP_TYPE_PERCPU_ARRAY[40;9H[1K */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;9H[35mreturn[39m(B[m (B[0;1m[31mXDP_PASS[39m(B[m;[38d}[40d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;1H(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[38d *[39d * User return codes for XDP prog type.[40d * A valid XDP program must return one of these defined values. All other[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;1m[34m * return codes are reserved for future use. Unknown return codes will[37d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[38d *[39denum xdp_action {[40;8H[1K XDP_ABORTED = 0,[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;8H(B[0;1m[34m[1K XDP_DROP,[37;8H[1K XDP_PASS,[38;8H[1K XDP_TX,[39;8H[1K XDP_REDIRECT,[40d};[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;1H(B[0;1m[34m * user accessible metadata for XDP packet hook[38d * new fields must be added to the end of this structure[39d *[40dstruct xdp_md {[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;8H(B[0;1m[34m[1K // (Note: type __u32 is NOT the real-type)[37;8H[1K __u32 data;[38;8H[1K __u32 data_end;[39;8H[1K __u32 data_meta;[40;8H[1K // Below access go through struct xdp_rxq_info[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;8H(B[0;1m[34m[1K __u32 ingress_ifindex; // rxq->dev->ifindex[37;8H[1K __u32 rx_queue_index;  // rxq->queue_index[38d};[39d*/[40d[39m(B[m[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[35d[?25l[?12l[?25h[30d[?25l[?12l[?25h[25d[?25l[?12l[?25h[20d[?25l[?12l[?25h[15d[?25l[?12l[?25h[10d[?25l[?12l[?25h[5d[?25l[?12l[?25h[2;40r[2;1H[2T[1;43r[2;9H(B[0;1m[34m/* Assignment#1: Add byte counters[3;9H[1K * - Hint look at struct xdp_md *ctx (copied below)[A[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[4;9H[1K * use an atomic operation.[5;9H[1K */[6;9H[39m(B[mlock_xadd(&rec->rx_packets, 1);[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H(B[0;1m[34m[1K * check isn't performed here. Even-though this is a static array where[3;9H[1K * we know key lookup XDP_PASS always will succeed.[4;9H[1K */[5;9H[33mif[39m(B[m (!rec)[6d[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[4;9H/* Lookup in kernel BPF-side return pointer to actual data record */[5;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[6;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[3d{[4;9H(B[0;1m[34m// void *data_end = (void *)(long)ctx->data_end;[5;9H// void *data     = (void *)(long)ctx->data;[6;9H(B[0m[32mstruct[39m(B[m datarec *rec;[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[36m#ifndef lock_xadd[3d#define[39m(B[m lock_xadd(ptr, val)     (([32mvoid[39m(B[m) __sync_fetch_and_add(ptr, val))[4d(B[0;1m[36m#endif[6d[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[2d[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H} xdp_stats_map (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m".maps"[39m(B[m);[4d(B[0;1m[34m/* LLVM maps __sync_fetch_and_add() as a built-in function to the BPF atomic add[5d * instruction (that is BPF_STX | BPF_XADD | BPF_W for word sizes)[6d */[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H[32mstruct[39m(B[m {[3d__uint(type, (B[0;1m[31mBPF_MAP_TYPE_ARRAY[39m(B[m);[4;9H__type(key, __u32);[5;9H__type(value, [32mstruct[39m(B[m datarec);[6;9H__uint(max_entries, (B[0;1m[31mXDP_ACTION_MAX[39m(B[m);[2d[?25l[?12l[?25h[7d[?25l[?12l[?25h[12d[?25l[?12l[?25h[17d[?25l[?12l[?25h[22d[?25l[?12l[?25h[27d[?25l[?12l[?25h[32d[?25l[?12l[?25h[37d[?25l[?12l[?25h[2;41r[41;1H[2S[1;43r[39;9H(B[0;1m[34m[1K * - Hint there is a map type named BPF_MAP_TYPE_PERCPU_ARRAY[40;9H[1K */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;9H[35mreturn[39m(B[m (B[0;1m[31mXDP_PASS[39m(B[m;[38d}[40d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;1H(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[38d *[39d * User return codes for XDP prog type.[40d * A valid XDP program must return one of these defined values. All other[39m(B[m[?25l[?12l[?25h[35d[?25l[?12l[?25h[30d[?25l[?12l[?25h[25d[?25l[?12l[?25h[30d[?25l[?12l[?25h[35d[?25l[?12l[?25h[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;1m[34m * return codes are reserved for future use. Unknown return codes will[37d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[38d *[39denum xdp_action {[40;8H[1K XDP_ABORTED = 0,[39m(B[m[?25l[?12l[?25h[35d[?25l[?12l[?25h[30d[?25l[?12l[?25h[25d[?25l[?12l[?25h[20d[?25l[?12l[?25h[15d[?25l[?12l[?25h[10d[?25l[?12l[?25h[5d[?25l[?12l[?25h[2;40r[2;1H[2T[1;43r[2;1H[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[3d{[A[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[36m#ifndef lock_xadd[3d#define[39m(B[m lock_xadd(ptr, val)     (([32mvoid[39m(B[m) __sync_fetch_and_add(ptr, val))[4d(B[0;1m[36m#endif[6d[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[2d[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H} xdp_stats_map (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m".maps"[39m(B[m);[4d(B[0;1m[34m/* LLVM maps __sync_fetch_and_add() as a built-in function to the BPF atomic add[5d * instruction (that is BPF_STX | BPF_XADD | BPF_W for word sizes)[6d */[2d[39m(B[m[?25l[42;15H            (B[0;7m^W(B[m Begin of Paragr.       (B[0;7m^Y(B[m First Line             (B[0;7m^T(B[m Go To Text[K[43;2H(B[0;7mC(B[m Cancel[17X[43;27H(B[0;7m^O(B[m End of Paragraph       (B[0;7m^V(B[m Last Line[K[42;92H[A(B[0;7mEnter line number, column number:                                                                       [41;35H(B[m[?12l[?25h[?25l[?12l[?25h[?25l[41;45H[1K (B[0;7m[ Cancelled ](B[m[K[42;15H(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut        (B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[43;2H(B[0;7mX(B[m Exit       (B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste      (B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[?12l[?25h[2d[?25l[?12l[?25h[3d[?25l[?12l[?25h[4d[?25l[?12l[?25h[5d[?25l[?12l[?25h[6d[?25l[?12l[?25h[7d[?25l[?12l[?25h[8d[?25l[?12l[?25h[9d[?25l[?12l[?25h[10d[?25l[?12l[?25h[11d[?25l[?12l[?25h[12d[?25l[?12l[?25h[C[?25l[?12l[?25h[13d[?25l[?12l[?25h[14d[?25l[?12l[?25h[14;9H[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[41d[K[?12l[?25h[14;15H[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[1;64H(B[0;7m*[103G(B[m[?12l[?25h[14;11H[1P[?25l[?12l[?25h/[32mvoid[39m(B[m *data_end = ([32mvoid[39m(B[m *)([32mlong[39m(B[m)ctx->data_end;[K[14;10H[?25l[?12l[?25h[1P[?25l[?12l[?25h[15d[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[1P[?25l[?12l[?25h/[32mvoid[39m(B[m *data     = ([32mvoid[39m(B[m *)([32mlong[39m(B[m)ctx->data;[K[15;10H[?25l[?12l[?25h[1P[?25l[41d(B[0;7mSave modified buffer?                                                                                   [42;1H Y(B[m Yes[K[43d(B[0;7m N(B[m No  [15G  (B[0;7m^C(B[m Cancel[K[41;23H[?12l[?25h[?25l[42d(B[0;7m^G(B[m Help[42;27H(B[0;7mM-D(B[m DOS Format[42;53H(B[0;7mM-A(B[m Append[42;79H(B[0;7mM-B(B[m Backup File[43d(B[0;7m^C(B[m Cancel[17G          (B[0;7mM-M(B[m Mac Format[43;53H(B[0;7mM-P(B[m Prepend[43;79H(B[0;7m^T(B[m Browse[41d(B[0;7mFile Name to Write: xdp_prog_kern.c(B[m[?12l[?25h[?25l[41;45H[1K (B[0;7m[ Writing... ](B[m[K[1;64H(B[0;7m [103G(B[m[41;44H(B[0;7m[ Wrote 85 lines ](B[m[J[43d[?12l[?25h[43;1H[?1049l[23;0;0t[?1l>[?2004l[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ nano xdp_prog_kern.c
[?2004l[?2004h[?1049h[22;0;0t[1;43r(B[m[4l[?7h[39;49m[?1h=[?1h=[?25l[39;49m(B[m[H[2J[41;46H(B[0;7m[ Reading... ](B[m[41;44H(B[0;7m[ Read 85 lines ](B[m[H(B[0;7m  GNU nano 7.2                                 xdp_prog_kern.c                                          [1;103H(B[m[42d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[42;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[43d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[2d(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d[36m#include[33m <linux/bpf.h>[4d[36m#include[33m <bpf/bpf_helpers.h>[6d[36m#include[39m(B[m (B[0;1m[33m"common_kern_user.h"[39m(B[m (B[0;1m[34m/* defines: struct datarec; */[8d/* Lesson#1: See how a map is defined.[9d * - Here an array with XDP_ACTION_MAX (max_)entries are created.[10d * - The idea is to keep stats per (enum) xdp_action[11d */[12d(B[0m[32mstruct[39m(B[m {[13d__uint(type, (B[0;1m[31mBPF_MAP_TYPE_ARRAY[39m(B[m);[14;9H__type(key, __u32);[15;9H__type(value, [32mstruct[39m(B[m datarec);[16;9H__uint(max_entries, (B[0;1m[31mXDP_ACTION_MAX[39m(B[m);[17d} xdp_stats_map (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m".maps"[39m(B[m);[19d(B[0;1m[34m/* LLVM maps __sync_fetch_and_add() as a built-in function to the BPF atomic add[20d * instruction (that is BPF_STX | BPF_XADD | BPF_W for word sizes)[21d */[22d[36m#ifndef lock_xadd[23d#define[39m(B[m lock_xadd(ptr, val)     (([32mvoid[39m(B[m) __sync_fetch_and_add(ptr, val))[24d(B[0;1m[36m#endif[26d[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[27d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[28d{[29;9H[32mvoid[39m(B[m *data_end = ([32mvoid[39m(B[m *)([32mlong[39m(B[m)ctx->data_end;[30;9H[32mvoid[39m(B[m *data     = ([32mvoid[39m(B[m *)([32mlong[39m(B[m)ctx->data;[31;9H[32mstruct[39m(B[m datarec *rec;[32;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[34;9H/* Lookup in kernel BPF-side return pointer to actual data record */[35;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[36;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[37;9H[1K * check isn't performed here. Even-though this is a static array where[38;9H[1K * we know key lookup XDP_PASS always will succeed.[39;9H[1K */[40;9H[33mif[39m(B[m (!rec)[2d[?12l[?25h[?25l[?12l[?25h[7d[?25l[?12l[?25h[12d[?25l[?12l[?25h[17d[?25l[41d[K[?12l[?25h[22d[?25l[?12l[?25h[27d[?25l[?12l[?25h[32d[?25l[?12l[?25h[37d[?25l[?12l[?25h[2;41r[41;1H[2S[1;43r[39;17H[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[37;9H[1K * use an atomic operation.[38;9H[1K */[39;9H[39m(B[mlock_xadd(&rec->rx_packets, 1);[40;9H(B[0;1m[34m/* Assignment#1: Add byte counters[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H(B[0;1m[34m[1K * - Hint look at struct xdp_md *ctx (copied below)[37;9H[1K *[38d[1K * Assignment#3: Avoid the atomic operation[39;9H[1K * - Hint there is a map type named BPF_MAP_TYPE_PERCPU_ARRAY[40;9H[1K */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;9H[35mreturn[39m(B[m (B[0;1m[31mXDP_PASS[39m(B[m;[38d}[40d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[?25l[?12l[?25h[35d[?25l[?12l[?25h[A[?25l[?12l[?25h[A[?25l[?12l[?25h[A[?25l[1;64H(B[0;7m*[103G(B[m[32;40r[32;1HM[1;43r[33;1H[?12l[?25h[?25l[?12l[?25h[A[?25l[2d}[K[3d[K[4d[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[5d[K[6d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[39m(B[m[K[7d(B[0;1m[34m *[39m(B[m[K[8d(B[0;1m[34m * User return codes for XDP prog type.[9d * A valid XDP program must return one of these defined values. All other[10d * return codes are reserved for future use. Unknown return codes will[11d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[12d *[39m(B[m[K[13d(B[0;1m[34menum xdp_action {[39m(B[m[K[14;8H(B[0;1m[34m[1K XDP_ABORTED = 0,[39m(B[m[K[15;8H(B[0;1m[34m[1K XDP_DROP,[39m(B[m[K[16;8H(B[0;1m[34m[1K XDP_PASS,[17;8H[1K XDP_TX,[39m(B[m[K[18;8H(B[0;1m[34m[1K XDP_REDIRECT,[39m(B[m[K[19d(B[0;1m[34m};[39m(B[m[K[20d[K[21;2H(B[0;1m[34m* user accessible metadata for XDP packet hook[39m(B[m[K[22;2H(B[0;1m[34m* new fields must be added to the end of this structure[23d *[39m(B[m[K[24d(B[0;1m[34mstruct xdp_md {[39m(B[m[K[25;8H(B[0;1m[34m[1K // (Note: type __u32 is NOT the real-type)[26;8H[1K __u32 data;[39m(B[m[K[27;9H(B[0;1m[34m__u32 data_end;[39m(B[m[K[28;9H(B[0;1m[34m__u32 data_meta;[29;8H[1K // Below access go through struct xdp_rxq_info[30;8H[1K __u32 ingress_ifindex; // rxq->dev->ifindex[31;9H__u32 rx_queue_index;  // rxq->queue_index[39m(B[m[K[32d(B[0;1m[34m};[33d*/[39m(B[m[K[34d[K[35d[K[36d[K[38d[K[39d[K[32d[?12l[?25h[?25l[?12l[?25h[27d[?25l[?12l[?25h[22d[?25l[?12l[?25h[17d[?25l[?12l[?25h[12d[?25l[?12l[?25h[7d[?25l[?12l[?25h[2d[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;9H(B[0;1m[34m[1K * Assignment#3: Avoid the atomic operation[3;9H[1K * - Hint there is a map type named BPF_MAP_TYPE_PERCPU_ARRAY[4;9H[1K */[6;9H(B[0m[35mreturn[39m(B[m (B[0;1m[31mXDP_PASS[39m(B[m;[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9Hlock_xadd(&rec->rx_packets, 1);[3;9H(B[0;1m[34m/* Assignment#1: Add byte counters[4;9H[1K * - Hint look at struct xdp_md *ctx (copied below)[6;9H[1K *[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;17H[35mreturn[39m(B[m (B[0;1m[31mXDP_ABORTED[39m(B[m;[4;9H(B[0;1m[34m/* Multiple CPUs can access data record. Thus, the accounting needs to[5;9H[1K * use an atomic operation.[6;9H[1K */[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H(B[0;1m[34m/* BPF kernel-side verifier will reject program if the NULL pointer[3;9H[1K * check isn't performed here. Even-though this is a static array where[4;9H[1K * we know key lookup XDP_PASS always will succeed.[5;9H[1K */[6;9H[33mif[39m(B[m (!rec)[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H[32mstruct[39m(B[m datarec *rec;[3;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m; (B[0;1m[34m/* XDP_PASS = 2 */[5;9H/* Lookup in kernel BPF-side return pointer to actual data record */[6;9H[39m(B[mrec = bpf_map_lookup_elem(&xdp_stats_map, &key);[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"xdp"[39m(B[m)[3d[32mint[39m(B[m  xdp_stats1_func([32mstruct[39m(B[m xdp_md *ctx)[4d{[5;9H[32mvoid[39m(B[m *data_end = ([32mvoid[39m(B[m *)([32mlong[39m(B[m)ctx->data_end;[6;9H[32mvoid[39m(B[m *data     = ([32mvoid[39m(B[m *)([32mlong[39m(B[m)ctx->data;[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[34m */[3d[36m#ifndef lock_xadd[4d#define[39m(B[m lock_xadd(ptr, val)     (([32mvoid[39m(B[m) __sync_fetch_and_add(ptr, val))[5d(B[0;1m[36m#endif[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H__uint(max_entries, (B[0;1m[31mXDP_ACTION_MAX[39m(B[m);[3d} xdp_stats_map (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m".maps"[39m(B[m);[5d(B[0;1m[34m/* LLVM maps __sync_fetch_and_add() as a built-in function to the BPF atomic add[6d * instruction (that is BPF_STX | BPF_XADD | BPF_W for word sizes)[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[34m */[3d(B[0m[32mstruct[39m(B[m {[4d__uint(type, (B[0;1m[31mBPF_MAP_TYPE_ARRAY[39m(B[m);[5;9H__type(key, __u32);[6;9H__type(value, [32mstruct[39m(B[m datarec);[2d[?25l[?12l[?25h[7d[?25l[?12l[?25h[12d[?25l[?12l[?25h[17d[?25l[?12l[?25h[22d[?25l[?12l[?25h[27d[?25l[?12l[?25h[32d[?25l[?12l[?25h[37d[?25l[?12l[?25h[2;41r[41;1H[2S[1;43r[39;9H(B[0;1m[34m[1K *[40d[1K * Assignment#3: Avoid the atomic operation[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H(B[0;1m[34m[1K * - Hint there is a map type named BPF_MAP_TYPE_PERCPU_ARRAY[37;9H[1K */[39;9H(B[0m[35mreturn[39m(B[m (B[0;1m[31mXDP_PASS[39m(B[m;[40d}[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;1H[32mchar[39m(B[m _license[] (B[0;1m[31mSEC[39m(B[m((B[0;1m[33m"license"[39m(B[m) = (B[0;1m[33m"GPL"[39m(B[m;[39d(B[0;1m[34m/* Copied from: $KERNEL/include/uapi/linux/bpf.h[40d *[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;1m[34m * User return codes for XDP prog type.[37d * A valid XDP program must return one of these defined values. All other[38d * return codes are reserved for future use. Unknown return codes will[39d * result in packet drops and a warning via bpf_warn_invalid_xdp_action().[40d *[39m(B[m[?25l[?12l[?25h[35d[?25l7[35;40r8M[1;43r[35;8H(B[0;1m[34m[1K __u64 bytes = data_end - data;[36;8H[1K lock_xadd(&rec->rx_bytes, bytes); *[39m(B[m[?12l[?25h[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34md *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[36;41r[41;1H
[1;43r[35;39H(B[0;1m[34m *[40d *[35;39H[39m(B[m[?12l[?25h[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m *[39m(B[m[K[?25l[?12l[?25h[C[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h(B[0;1m[34m*[39m(B[m[K[?25l[?12l[?25h[C[?25l[?12l[?25h[42m[1K [49m(B[m [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h[K[?25l[35;41r[41;1H
[1;43r[40;1H(B[0;1m[34menum xdp_action {[34;49H[39m(B[m[?12l[?25h[?25l[?12l[?25h [?25l[?12l[?25h(B[0;1m[34mh[39m(B[m[?25l[?12l[?25h[29;25H[?25l[?12l[?25h[24;11H[?25l[?12l[?25h[19;12H[?25l[?12l[?25h[14;18H[?25l[?12l[?25h[9;49H[?25l[?12l[?25h[14;18H[?25l[?12l[?25h[19;12H[?25l[?12l[?25h[20;40H[?25l[?12l[?25h[21;43H[?25l[?12l[?25h[22;49H[?25l[?12l[?25h[23d[?25l7[23;40r8M[1;43r[23;8H(B[0;1m[34m[1K __u64 bytes = data_end - data;[24;8H[1K lock_xadd(&rec->rx_bytes, bytes);[39m(B[m[?12l[?25h[?25l[?12l[?25h[A[?25l[?12l[?25h [?25l[?12l[?25h[24d[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h[C[?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h[42m [49m(B[m[K[?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[?12l[?25h [?25l[K[?12l[?25h[?25l[14G[K[?12l[?25h[?25l[8G[42m[1K [49m(B[m[K[?12l[?25h[?25l[K[?12l[?25h[?25l[24;41r[41;1H
[1;43r[40;1H(B[0;1m[34menum xdp_action {[23;38H[39m(B[m[?12l[?25h[?25l[33G[42m [49m(B[m[K[?12l[?25h[?25l[28G[K[?12l[?25h[?25l[22G[42m [49m(B[m[K[?12l[?25h[?25l[23;14H[42m [49m(B[m[K[?12l[?25h[?25l[K[?12l[?25h[?25l[K[?12l[?25h[?25l[23;41r[41;1H
[1;43r[40;8H(B[0;1m[34m[1K XDP_ABORTED = 0,[22;60H[39m(B[m[?12l[?25h[?25l[?12l[?25h[23;11H[?25l[?12l[?25h[24;52H[?25l[?12l[?25h[25;60H[?25l[?12l[?25h[26;12H[?25l[?12l[?25h[27d[?25l[?12l[?25h[26;12H[?25l7[27;40r8[27dM[1;43r[27;1H[?12l[?25h[?25l[?12l[?25h[8G[42m[1K [49m(B[m[?25l7[27;40r8M[1;43r[27;17H__u64 bytes = data_end - data;[28;8H[1K lock_xadd(&rec->rx_bytes, bytes);[?12l[?25h[?25l[?12l[?25h[A[?25l[?12l[?25h[?25l[41;38H(B[0;1m[37m[41m[ No more open file buffers ][39;49m(B[m[?12l[?25h[27;41H[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[41d[K[?12l[?25h[27;21H[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[1P[27;16H[?25l[?12l[?25h[1P[27;15H[?25l[?12l[?25h[1P[27;14H[?25l[?12l[?25h[1P[27;13H[?25l[?12l[?25h[1P[27;12H[?25l[?12l[?25h[1P[27;11H[?25l[?12l[?25h[1P[27;10H[?25l[?12l[?25h[1P[27;9H[?25l[?12l[?25h[?25l[41d(B[0;7mSave modified buffer?                                                                                   [42;1H Y(B[m Yes[K[43d(B[0;7m N(B[m No  [15G  (B[0;7m^C(B[m Cancel[K[41;23H[?12l[?25h[?25l[42d(B[0;7m^G(B[m Help[42;27H(B[0;7mM-D(B[m DOS Format[42;53H(B[0;7mM-A(B[m Append[42;79H(B[0;7mM-B(B[m Backup File[43d(B[0;7m^C(B[m Cancel[17G          (B[0;7mM-M(B[m Mac Format[43;53H(B[0;7mM-P(B[m Prepend[43;79H(B[0;7m^T(B[m Browse[41d(B[0;7mFile Name to Write: xdp_prog_kern.c(B[m[?12l[?25h[?25l[41;45H[1K (B[0;7m[ Writing... ](B[m[K[1;64H(B[0;7m [103G(B[m[41;44H(B[0;7m[ Wrote 86 lines ](B[m[J[43d[?12l[?25h[43;1H[?1049l[23;0;0t[?1l>[?2004l[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ ls
[?2004lcommon_kern_user.h  README.org          xdp_load_and_stats.c  xdp_prog_kern.o
Makefile            [0m[01;32mxdp_load_and_stats[0m  xdp_prog_kern.c
[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ xdp[K[K[Kcd p[Kxpd[K[Kdp_;[Kload_and_stats.c
[?2004lbash: cd: xdp_load_and_stats.c: Not a directory
[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ nano cd xdp_load_and_stats.cnano [Kxdp_load_and_stas[Kts.c
[?2004l[?2004h[?1049h[22;0;0t[1;43r(B[m[4l[?7h[39;49m[?1h=[?1h=[?25l[39;49m(B[m[H[2J[41;46H(B[0;7m[ Reading... ](B[m[41;44H(B[0;7m[ Read 351 lines ](B[m[H(B[0;7m  GNU nano 7.2                              xdp_load_and_stats.c                                        [1;103H(B[m[42d(B[0;7m^G(B[m Help[15G(B[0;7m^O(B[m Write Out  (B[0;7m^W(B[m Where Is   (B[0;7m^K(B[m Cut[42;57H(B[0;7m^T(B[m Execute    (B[0;7m^C(B[m Location   (B[0;7mM-U(B[m Undo[43d(B[0;7m^X(B[m Exit[15G(B[0;7m^R(B[m Read File  (B[0;7m^\(B[m Replace    (B[0;7m^U(B[m Paste[57G(B[0;7m^J(B[m Justify    (B[0;7m^/(B[m Go To Line (B[0;7mM-E(B[m Redo[2d(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d(B[0m[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *__doc__ = (B[0;1m[33m"XDP loader and stats program\n"[4;9H" - Allows selecting BPF --progname name to XDP-attach to --dev\n"[39m(B[m;[6d(B[0;1m[36m#include[33m <stdio.h>[7d[36m#include[33m <stdlib.h>[8d[36m#include[33m <string.h>[9d[36m#include[33m <errno.h>[10d[36m#include[33m <getopt.h>[12d[36m#include[33m <locale.h>[13d[36m#include[33m <unistd.h>[14d[36m#include[33m <time.h>[16d[36m#include[33m <bpf/bpf.h>[17d[36m#include[33m <bpf/libbpf.h>[18d[36m#include[33m <xdp/libxdp.h>[20d[36m#include[33m <net/if.h>[21d[36m#include[33m <linux/if_link.h>[39m(B[m (B[0;1m[34m/* depend on kernel-headers installed */[23d[36m#include[39m(B[m (B[0;1m[33m"../common/common_params.h"[24d[36m#include[39m(B[m (B[0;1m[33m"../common/common_user_bpf_xdp.h"[25d[36m#include[39m(B[m (B[0;1m[33m"common_kern_user.h"[27d(B[0m[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *default_filename = (B[0;1m[33m"xdp_prog_kern.o"[39m(B[m;[28d[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *default_progname = (B[0;1m[33m"xdp_stats1_func"[39m(B[m;[30d[32mstatic[39m(B[m [32mconst[39m(B[m [32mstruct[39m(B[m option_wrapper long_options[] = {[31;9H{{(B[0;1m[33m"help"[39m(B[m,[31;26Hno_argument,[31;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'h'[39m(B[m },[32;10H(B[0;1m[33m"Show help"[39m(B[m, false},[34;9H{{(B[0;1m[33m"dev"[39m(B[m,[34;26Hrequired_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'd'[39m(B[m },[35;10H(B[0;1m[33m"Operate on device <ifname>"[39m(B[m, (B[0;1m[33m"<ifname>"[39m(B[m, true},[37;9H{{(B[0;1m[33m"skb-mode"[39m(B[m,    no_argument,[37;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'S'[39m(B[m },[38;10H(B[0;1m[33m"Install XDP program in SKB (AKA generic) mode"[39m(B[m},[40;9H{{(B[0;1m[33m"native-mode"[39m(B[m, no_argument,[40;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'N'[39m(B[m },[2d[?12l[?25h[?25l[?12l[?25h[7d[?25l[?12l[?25h[12d[?25l[?12l[?25h[17d[?25l[41d[K[?12l[?25h[12d[?25l[?12l[?25h[7d[?25l[?12l[?25h[2d[?25l[?12l[?25h[7d[?25l[?12l[?25h[12d[?25l[?12l[?25h[17d[?25l[?12l[?25h[22d[?25l[?12l[?25h[27d[?25l[?12l[?25h[32d[?25l[?12l[?25h[37d[?25l[?12l[?25h[2;41r[41;1H[2S[1;43r[39;10H(B[0;1m[33m"Install XDP program in native mode"[39m(B[m},[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H{{(B[0;1m[33m"auto-mode"[39m(B[m,   no_argument,[36;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'A'[39m(B[m },[37;10H(B[0;1m[33m"Auto-detect SKB or native mode"[39m(B[m},[39;9H{{(B[0;1m[33m"unload"[39m(B[m,[26Grequired_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'U'[39m(B[m },[40;10H(B[0;1m[33m"Unload XDP program <id> instead of loading"[39m(B[m, (B[0;1m[33m"<id>"[39m(B[m},[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;9H{{(B[0;1m[33m"unload-all"[39m(B[m,  no_argument,[37;49H(B[0;1m[31mNULL[39m(B[m,  4  },[38;10H(B[0;1m[33m"Unload all XDP programs on device"[39m(B[m},[40;9H{{(B[0;1m[33m"quiet"[39m(B[m,[26Gno_argument,[40;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'q'[39m(B[m },[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;10H(B[0;1m[33m"Quiet mode (no output)"[39m(B[m},[38;9H{{(B[0;1m[33m"filename"[39m(B[m,    required_argument,     (B[0;1m[31mNULL[39m(B[m,  1  },[39;10H(B[0;1m[33m"Load program from <file>"[39m(B[m, (B[0;1m[33m"<file>"[39m(B[m},[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H{{(B[0;1m[33m"progname"[39m(B[m,    required_argument,     (B[0;1m[31mNULL[39m(B[m,  2  },[37;10H(B[0;1m[33m"Load program from function <name> in the ELF file"[39m(B[m, (B[0;1m[33m"<name>"[39m(B[m},[39;9H{{0, 0, (B[0;1m[31mNULL[39m(B[m,  0 }}[40d};[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;1H[32mint[39m(B[m find_map_fd([32mstruct[39m(B[m bpf_object *bpf_obj, [32mconst[39m(B[m [32mchar[39m(B[m *mapname)[38d{[39;9H[32mstruct[39m(B[m bpf_map *map;[40;9H[32mint[39m(B[m map_fd = -1;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;9H(B[0;1m[34m/* Lesson#3: bpf_object to bpf_map */[38;9H[39m(B[mmap = bpf_object__find_map_by_name(bpf_obj, mapname);[39;9H(B[0;1m[33mif[39m(B[m (!map) {[40;17Hfprintf(stderr, (B[0;1m[33m"ERR: cannot find map by name: %s\n"[39m(B[m, mapname);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;17H[35mgoto[39m(B[m out;[37;9H}[39dmap_fd = bpf_map__fd(map);[40d(B[0;1m[35m out(B[0m:(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H[35mreturn[39m(B[m map_fd;[37d}[39d(B[0;1m[36m#define[39m(B[m (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m 1000000000 (B[0;1m[34m/* 10^9 */[40d(B[0m[32mstatic[39m(B[m __u64 gettime([32mvoid[39m(B[m)[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H{[37;9H[32mstruct[39m(B[m timespec t;[38;9H[32mint[39m(B[m res;[40;9Hres = clock_gettime((B[0;1m[31mCLOCK_MONOTONIC[39m(B[m, &t);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H(B[0;1m[33mif[39m(B[m (res < 0) {[37;17Hfprintf(stderr, (B[0;1m[33m"Error with gettimeofday! (%i)\n"[39m(B[m, res);[38;17Hexit((B[0;1m[31mEXIT_FAIL[39m(B[m);[39;9H}[40d[35mreturn[39m(B[m (__u64) t.tv_sec * (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m + t.tv_nsec;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H}[38d[32mstruct[39m(B[m record {[39;9H__u64 timestamp;[40;9H[32mstruct[39m(B[m datarec total; (B[0;1m[34m/* defined in common_kern_user.h */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H};[38d[32mstruct[39m(B[m stats_record {[39;9H[32mstruct[39m(B[m record stats[1]; (B[0;1m[34m/* Assignment#2: Hint */[40d[39m(B[m};[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;1H[32mstatic[39m(B[m [32mdouble[39m(B[m calc_period([32mstruct[39m(B[m record *r, [32mstruct[39m(B[m record *p)[38d{[39;9H[32mdouble[39m(B[m period_ = 0;[40;9H__u64 period = 0;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;9Hperiod = r->timestamp - p->timestamp;[38;9H(B[0;1m[33mif[39m(B[m (period > 0)[39;17Hperiod_ = (([32mdouble[39m(B[m) period / (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m);[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H[35mreturn[39m(B[m period_;[37d}[39d[32mstatic[39m(B[m [32mvoid[39m(B[m stats_print([32mstruct[39m(B[m stats_record *stats_rec,[40;25H[32mstruct[39m(B[m stats_record *stats_prev)[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H{[37;9H[32mstruct[39m(B[m record *rec, *prev;[38;9H[32mdouble[39m(B[m period;[39;9H__u64 packets;[40;9H[32mdouble[39m(B[m pps; (B[0;1m[34m/* packets per sec */[39m(B[m[?25l[?12l[?25h[35d[?25l[?12l[?25h[30d[?25l[?12l[?25h[25d[?25l[?12l[?25h[20d[?25l[?12l[?25h[15d[?25l[?12l[?25h[10d[?25l[?12l[?25h[5d[?25l[?12l[?25h[2;40r[2;1H[2T[1;43r[2;1H[32mstatic[39m(B[m __u64 gettime([32mvoid[39m(B[m)[3d{[A[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[35m out(B[0m:[3;9H[35mreturn[39m(B[m map_fd;[4d}[6d(B[0;1m[36m#define[39m(B[m (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m 1000000000 (B[0;1m[34m/* 10^9 */[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;17Hfprintf(stderr, (B[0;1m[33m"ERR: cannot find map by name: %s\n"[39m(B[m, mapname);[3;17H[35mgoto[39m(B[m out;[4;9H}[6dmap_fd = bpf_map__fd(map);[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H[32mint[39m(B[m map_fd = -1;[4;9H(B[0;1m[34m/* Lesson#3: bpf_object to bpf_map */[5;9H[39m(B[mmap = bpf_object__find_map_by_name(bpf_obj, mapname);[6;9H(B[0;1m[33mif[39m(B[m (!map) {[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H};[4d[32mint[39m(B[m find_map_fd([32mstruct[39m(B[m bpf_object *bpf_obj, [32mconst[39m(B[m [32mchar[39m(B[m *mapname)[5d{[6;9H[32mstruct[39m(B[m bpf_map *map;[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;9H{{(B[0;1m[33m"progname"[39m(B[m,    required_argument,     (B[0;1m[31mNULL[39m(B[m,  2  },[4;10H(B[0;1m[33m"Load program from function <name> in the ELF file"[39m(B[m, (B[0;1m[33m"<name>"[39m(B[m},[6;9H{{0, 0, (B[0;1m[31mNULL[39m(B[m,  0 }}[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H{{(B[0;1m[33m"quiet"[39m(B[m,[26Gno_argument,[2;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'q'[39m(B[m },[3;10H(B[0;1m[33m"Quiet mode (no output)"[39m(B[m},[5;9H{{(B[0;1m[33m"filename"[39m(B[m,    required_argument,     (B[0;1m[31mNULL[39m(B[m,  1  },[6;10H(B[0;1m[33m"Load program from <file>"[39m(B[m, (B[0;1m[33m"<file>"[39m(B[m},[2d[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;10H(B[0;1m[33m"Unload XDP program <id> instead of loading"[39m(B[m, (B[0;1m[33m"<id>"[39m(B[m},[4;9H{{(B[0;1m[33m"unload-all"[39m(B[m,  no_argument,[4;49H(B[0;1m[31mNULL[39m(B[m,  4  },[5;10H(B[0;1m[33m"Unload all XDP programs on device"[39m(B[m},[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;9H{{(B[0;1m[33m"auto-mode"[39m(B[m,   no_argument,[3;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'A'[39m(B[m },[4;10H(B[0;1m[33m"Auto-detect SKB or native mode"[39m(B[m},[6;9H{{(B[0;1m[33m"unload"[39m(B[m,[26Grequired_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'U'[39m(B[m },[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H{{(B[0;1m[33m"skb-mode"[39m(B[m,    no_argument,[2;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'S'[39m(B[m },[3;10H(B[0;1m[33m"Install XDP program in SKB (AKA generic) mode"[39m(B[m},[5;9H{{(B[0;1m[33m"native-mode"[39m(B[m, no_argument,[5;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'N'[39m(B[m },[6;10H(B[0;1m[33m"Install XDP program in native mode"[39m(B[m},[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;10H(B[0;1m[33m"Show help"[39m(B[m, false},[4;9H{{(B[0;1m[33m"dev"[39m(B[m,[4;26Hrequired_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'd'[39m(B[m },[5;10H(B[0;1m[33m"Operate on device <ifname>"[39m(B[m, (B[0;1m[33m"<ifname>"[39m(B[m, true},[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *default_filename = (B[0;1m[33m"xdp_prog_kern.o"[39m(B[m;[3d[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *default_progname = (B[0;1m[33m"xdp_stats1_func"[39m(B[m;[5d[32mstatic[39m(B[m [32mconst[39m(B[m [32mstruct[39m(B[m option_wrapper long_options[] = {[6;9H{{(B[0;1m[33m"help"[39m(B[m,[6;26Hno_argument,[6;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'h'[39m(B[m },[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H(B[0;1m[36m#include[39m(B[m (B[0;1m[33m"../common/common_params.h"[4d[36m#include[39m(B[m (B[0;1m[33m"../common/common_user_bpf_xdp.h"[5d[36m#include[39m(B[m (B[0;1m[33m"common_kern_user.h"[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[36m#include[33m <bpf/libbpf.h>[3d[36m#include[33m <xdp/libxdp.h>[5d[36m#include[33m <net/if.h>[6d[36m#include[33m <linux/if_link.h>[39m(B[m (B[0;1m[34m/* depend on kernel-headers installed */[2d[39m(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H(B[0;1m[36m#include[33m <locale.h>[3d[36m#include[33m <unistd.h>[4d[36m#include[33m <time.h>[6d[36m#include[33m <bpf/bpf.h>[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[36m#include[33m <stdlib.h>[3d[36m#include[33m <string.h>[4d[36m#include[33m <errno.h>[5d[36m#include[33m <getopt.h>[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d(B[0m[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *__doc__ = (B[0;1m[33m"XDP loader and stats program\n"[4;9H" - Allows selecting BPF --progname name to XDP-attach to --dev\n"[39m(B[m;[6d(B[0;1m[36m#include[33m <stdio.h>[2d[39m(B[m[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[7d[?25l[?12l[?25h[12d[?25l[?12l[?25h[17d[?25l[?12l[?25h[22d[?25l[?12l[?25h[27d[?25l[?12l[?25h[22d[?25l[?12l[?25h[17d[?25l[?12l[?25h[12d[?25l[?12l[?25h[7d[?25l[?12l[?25h[2d[?25l[?12l[?25h[7d[?25l[?12l[?25h[12d[?25l[?12l[?25h[17d[?25l[?12l[?25h[22d[?25l[?12l[?25h[27d[?25l[?12l[?25h[32d[?25l[?12l[?25h[37d[?25l[?12l[?25h[2;41r[41;1H[2S[1;43r[39;10H(B[0;1m[33m"Install XDP program in native mode"[39m(B[m},[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H{{(B[0;1m[33m"auto-mode"[39m(B[m,   no_argument,[36;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'A'[39m(B[m },[37;10H(B[0;1m[33m"Auto-detect SKB or native mode"[39m(B[m},[39;9H{{(B[0;1m[33m"unload"[39m(B[m,[26Grequired_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'U'[39m(B[m },[40;10H(B[0;1m[33m"Unload XDP program <id> instead of loading"[39m(B[m, (B[0;1m[33m"<id>"[39m(B[m},[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;9H{{(B[0;1m[33m"unload-all"[39m(B[m,  no_argument,[37;49H(B[0;1m[31mNULL[39m(B[m,  4  },[38;10H(B[0;1m[33m"Unload all XDP programs on device"[39m(B[m},[40;9H{{(B[0;1m[33m"quiet"[39m(B[m,[26Gno_argument,[40;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'q'[39m(B[m },[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;10H(B[0;1m[33m"Quiet mode (no output)"[39m(B[m},[38;9H{{(B[0;1m[33m"filename"[39m(B[m,    required_argument,     (B[0;1m[31mNULL[39m(B[m,  1  },[39;10H(B[0;1m[33m"Load program from <file>"[39m(B[m, (B[0;1m[33m"<file>"[39m(B[m},[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H{{(B[0;1m[33m"progname"[39m(B[m,    required_argument,     (B[0;1m[31mNULL[39m(B[m,  2  },[37;10H(B[0;1m[33m"Load program from function <name> in the ELF file"[39m(B[m, (B[0;1m[33m"<name>"[39m(B[m},[39;9H{{0, 0, (B[0;1m[31mNULL[39m(B[m,  0 }}[40d};[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;1H[32mint[39m(B[m find_map_fd([32mstruct[39m(B[m bpf_object *bpf_obj, [32mconst[39m(B[m [32mchar[39m(B[m *mapname)[38d{[39;9H[32mstruct[39m(B[m bpf_map *map;[40;9H[32mint[39m(B[m map_fd = -1;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;9H(B[0;1m[34m/* Lesson#3: bpf_object to bpf_map */[38;9H[39m(B[mmap = bpf_object__find_map_by_name(bpf_obj, mapname);[39;9H(B[0;1m[33mif[39m(B[m (!map) {[40;17Hfprintf(stderr, (B[0;1m[33m"ERR: cannot find map by name: %s\n"[39m(B[m, mapname);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;17H[35mgoto[39m(B[m out;[37;9H}[39dmap_fd = bpf_map__fd(map);[40d(B[0;1m[35m out(B[0m:(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H[35mreturn[39m(B[m map_fd;[37d}[39d(B[0;1m[36m#define[39m(B[m (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m 1000000000 (B[0;1m[34m/* 10^9 */[40d(B[0m[32mstatic[39m(B[m __u64 gettime([32mvoid[39m(B[m)[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H{[37;9H[32mstruct[39m(B[m timespec t;[38;9H[32mint[39m(B[m res;[40;9Hres = clock_gettime((B[0;1m[31mCLOCK_MONOTONIC[39m(B[m, &t);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H(B[0;1m[33mif[39m(B[m (res < 0) {[37;17Hfprintf(stderr, (B[0;1m[33m"Error with gettimeofday! (%i)\n"[39m(B[m, res);[38;17Hexit((B[0;1m[31mEXIT_FAIL[39m(B[m);[39;9H}[40d[35mreturn[39m(B[m (__u64) t.tv_sec * (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m + t.tv_nsec;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H}[38d[32mstruct[39m(B[m record {[39;9H__u64 timestamp;[40;9H[32mstruct[39m(B[m datarec total; (B[0;1m[34m/* defined in common_kern_user.h */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H};[38d[32mstruct[39m(B[m stats_record {[39;9H[32mstruct[39m(B[m record stats[1]; (B[0;1m[34m/* Assignment#2: Hint */[40d[39m(B[m};[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;1H[32mstatic[39m(B[m [32mdouble[39m(B[m calc_period([32mstruct[39m(B[m record *r, [32mstruct[39m(B[m record *p)[38d{[39;9H[32mdouble[39m(B[m period_ = 0;[40;9H__u64 period = 0;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;9Hperiod = r->timestamp - p->timestamp;[38;9H(B[0;1m[33mif[39m(B[m (period > 0)[39;17Hperiod_ = (([32mdouble[39m(B[m) period / (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m);[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H[35mreturn[39m(B[m period_;[37d}[39d[32mstatic[39m(B[m [32mvoid[39m(B[m stats_print([32mstruct[39m(B[m stats_record *stats_rec,[40;25H[32mstruct[39m(B[m stats_record *stats_prev)[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H{[37;9H[32mstruct[39m(B[m record *rec, *prev;[38;9H[32mdouble[39m(B[m period;[39;9H__u64 packets;[40;9H[32mdouble[39m(B[m pps; (B[0;1m[34m/* packets per sec */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;9H(B[0;1m[34m/* Assignment#2: Print other XDP actions stats  */[38;9H[39m(B[m{[39;17H[32mchar[39m(B[m *fmt = (B[0;1m[33m"%-12s %'11lld pkts (%'10.0f pps)"[40;25H[34m//" %'11lld Kbytes (%'6.0f Mbits/s)"[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;25H(B[0;1m[33m" period:%f\n"[39m(B[m;[37;17H[32mconst[39m(B[m [32mchar[39m(B[m *action = action2str((B[0;1m[31mXDP_PASS[39m(B[m);[38;17Hrec  = &stats_rec->stats[0];[39;17Hprev = &stats_prev->stats[0];[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;17Hperiod = calc_period(rec, prev);[37;17H(B[0;1m[33mif[39m(B[m (period == 0)[38;24H[35mreturn[39m(B[m;[40;17Hpackets = rec->total.rx_packets - prev->total.rx_packets;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;17Hpps     = packets / period;[38;17Hprintf(fmt, action, rec->total.rx_packets, pps, period);[39;9H}[40d}[?25l[?12l[?25h[35d[?25l[?12l[?25h[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;1H(B[0;1m[34m/* BPF_MAP_TYPE_ARRAY */[38d(B[0m[32mvoid[39m(B[m map_get_value_array([32mint[39m(B[m fd, __u32 key, [32mstruct[39m(B[m datarec *value)[39d{[40;9H(B[0;1m[33mif[39m(B[m ((bpf_map_lookup_elem(fd, &key, value)) != 0) {[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;17Hfprintf(stderr,[37;25H(B[0;1m[33m"ERR: bpf_map_lookup_elem failed key:0x%X\n"[39m(B[m, key);[38;9H}[39d}[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;1m[34m/* BPF_MAP_TYPE_PERCPU_ARRAY */[37d(B[0m[32mvoid[39m(B[m map_get_value_percpu_array([32mint[39m(B[m fd, __u32 key, [32mstruct[39m(B[m datarec *value)[38d{[39;9H(B[0;1m[34m/* For percpu maps, userspace gets a value per possible CPU */[40;9H// unsigned int nr_cpus = libbpf_num_possible_cpus();[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H(B[0;1m[34m// struct datarec values[nr_cpus];[38;9H[39m(B[mfprintf(stderr, (B[0;1m[33m"ERR: %s() not impl. see assignment#3"[39m(B[m, __func__);[39d}[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H[32mstatic[39m(B[m [32mbool[39m(B[m map_collect([32mint[39m(B[m fd, __u32 map_type, __u32 key, [32mstruct[39m(B[m record *rec)[37d{[38;9H[32mstruct[39m(B[m datarec value;[40;9H(B[0;1m[34m/* Get time as close as possible to reading map contents */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9Hrec->timestamp = gettime();[38;9H(B[0;1m[33mswitch[39m(B[m (map_type) {[39;9H(B[0;1m[33mcase[39m(B[m (B[0;1m[31mBPF_MAP_TYPE_ARRAY(B[0m:[40;17H(B[mmap_get_value_array(fd, key, &value);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;17H[35mbreak[39m(B[m;[37;9H(B[0;1m[33mcase[39m(B[m (B[0;1m[31mBPF_MAP_TYPE_PERCPU_ARRAY(B[0m:[38;17H(B[0;1m[34m/* fall-through */[39;8H[35m[1K [33mdefault(B[0m:[40d(B[mfprintf(stderr, (B[0;1m[33m"ERR: Unknown map_type(%u) cannot handle\n"[39m(B[m,[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;25Hmap_type);[37;17H[35mreturn[39m(B[m false;[38;17H[35mbreak[39m(B[m;[39;9H}[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H(B[0;1m[34m/* Assignment#1: Add byte counters */[37;9H[39m(B[mrec->total.rx_packets = value.rx_packets;[38;9H[35mreturn[39m(B[m true;[39d}[40d[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H[32mstatic[39m(B[m [32mvoid[39m(B[m stats_collect([32mint[39m(B[m map_fd, __u32 map_type,[37;27H[32mstruct[39m(B[m stats_record *stats_rec)[38d{[39;9H(B[0;1m[34m/* Assignment#2: Collect other XDP actions stats  */[40;9H[39m(B[m__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;9Hmap_collect(map_fd, map_type, key, &stats_rec->stats[0]);[38d}[40d[32mstatic[39m(B[m [32mvoid[39m(B[m stats_poll([32mint[39m(B[m map_fd, __u32 map_type, [32mint[39m(B[m interval)[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H{[37;9H[32mstruct[39m(B[m stats_record prev, record = { 0 };[39;9H(B[0;1m[34m/* Trick to pretty printf with thousands separators use %' */[40;9H[39m(B[msetlocale((B[0;1m[31mLC_NUMERIC[39m(B[m, (B[0;1m[33m"en_US"[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;9H(B[0;1m[34m/* Print stats "header" */[38;9H[33mif[39m(B[m (verbose) {[39;17Hprintf((B[0;1m[33m"\n"[39m(B[m);[40;17Hprintf((B[0;1m[33m"%-12s\n"[39m(B[m, (B[0;1m[33m"XDP-action"[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;9H}[38d(B[0;1m[34m/* Get initial reading quickly */[39;9H[39m(B[mstats_collect(map_fd, map_type, &record);[40;9Husleep(1000000/4);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[37;9H(B[0;1m[33mwhile[39m(B[m (1) {[38;17Hprev = record; (B[0;1m[34m/* struct copy */[39;17H[39m(B[mstats_collect(map_fd, map_type, &record);[40;17Hstats_print(&record, &prev);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;17Hsleep(interval);[37;9H}[38d}[40d(B[0;1m[34m/* Lesson#4: It is userspace responsibility to known what map it is reading and[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;1m[34m * know the value size. Here get bpf_map_info and check if it match our expected[37d * values.[38d */[39d(B[0m[32mstatic[39m(B[m [32mint[39m(B[m __check_map_fd_info([32mint[39m(B[m map_fd, [32mstruct[39m(B[m bpf_map_info *info,[40;32H[32mstruct[39m(B[m bpf_map_info *exp)[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H{[37;9H__u32 info_len = [32msizeof[39m(B[m(*info);[38;9H[32mint[39m(B[m err;[40;9H(B[0;1m[33mif[39m(B[m (map_fd < 0)[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;17H[35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[38;9H(B[0;1m[34m/* BPF-info via bpf-syscall */[39;9H[39m(B[merr = bpf_obj_get_info_by_fd(map_fd, info, &info_len);[40;9H(B[0;1m[33mif[39m(B[m (err) {[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;17Hfprintf(stderr, (B[0;1m[33m"ERR: %s() can't get info - %s\n"[39m(B[m,[37;25H__func__,  strerror(errno));[38;17H[35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL_BPF[39m(B[m;[39;9H}[40d[?25l[41;47H(B[0;7m[ Mark Set ](B[m[1;99H(B[0;7mM   (B[m[?12l[?25h[40d[?25l[?12l[?25h7[2;40r8[5S[1;43r[36;1H(B[0;7m        if (exp->key_size && exp->key_size != info->key_size) {[37d                fprintf(stderr, "ERR: %s() "[38d                        "Map key size(%d) mismatch expected size(%d)\n",[39d                        __func__, info->key_size, exp->key_size);[40;17H(B[0m[35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[?25l[?12l[?25h7[2;40r8[5S[1;43r[35;1H(B[0;7m                return EXIT_FAIL;[36d        }[37d        if (exp->value_size && exp->value_size != info->value_size) {[38d                fprintf(stderr, "ERR: %s() "[39d                        "Map value size(%d) mismatch expected size(%d)\n",[40;25H(B[m__func__, info->value_size, exp->value_size);[?25l[?12l[?25h7[2;40r8[5S[1;43r[35;1H(B[0;7m                        __func__, info->value_size, exp->value_size);[36d                return EXIT_FAIL;[37d        }[38d        if (exp->max_entries && exp->max_entries != info->max_entries) {[39d                fprintf(stderr, "ERR: %s() "[40;25H(B[0;1m[33m"Map max_entries(%d) mismatch expected size(%d)\n"[39m(B[m,[?25l[41d[K[?12l[?25h7[2;41r8[5S[1;43r[35;1H(B[0;7m                        "Map max_entries(%d) mismatch expected size(%d)\n",[36d                        __func__, info->max_entries, exp->max_entries);[37d                return EXIT_FAIL;[38d        }[39d        if (exp->type && exp->type  != info->type) {[40;17H(B[mfprintf(stderr, (B[0;1m[33m"ERR: %s() "[39m(B[m[?25l[?12l[?25h[35;24H[1K (B[0;1m[33m"Map max_entries(%d) mismatch expected size(%d)\n"[39m(B[m,[36;24H[1K __func__, info->max_entries, exp->max_entries);[37;16H[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[38;8H[1K }[39d[1K (B[0;1m[33mif[39m(B[m (exp->type && exp->type  != info->type) {[35d[?25l[?12l[?25h[30;24H[1K __func__, info->value_size, exp->value_size);[31;16H[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[32;8H[1K }[33d[1K (B[0;1m[33mif[39m(B[m (exp->max_entries && exp->max_entries != info->max_entries) {[34;16H[1K fprintf(stderr, (B[0;1m[33m"ERR: %s() "[30d[39m(B[m[?25l[?12l[?25h(B[0;7m                        __func__, info->value_size, exp->value_size);[31d                return EXIT_FAIL;[32d        }[33d        if (exp->max_entries && exp->max_entries != info->max_entries) {[34d                fprintf(stderr, "ERR: %s() "[35d(B[m[?25l[?12l[?25h(B[0;7m                        "Map max_entries(%d) mismatch expected size(%d)\n",[36d                        __func__, info->max_entries, exp->max_entries);[37d                return EXIT_FAIL;[38d        }[39d        if (exp->type && exp->type  != info->type) {[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                fprintf(stderr, "ERR: %s() "[36d                        "Map type(%d) mismatch expected type(%d)\n",[37d                        __func__, info->type, exp->type);[38d                return EXIT_FAIL;[39d        }[40d(B[m[?25l[?12l[?25h[35;16H[1K fprintf(stderr, (B[0;1m[33m"ERR: %s() "[36;24H[39m(B[m[1K (B[0;1m[33m"Map type(%d) mismatch expected type(%d)\n"[39m(B[m,[37;24H[1K __func__, info->type, exp->type);[38;16H[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[39;8H[1K }[35d[?25l[?12l[?25h[30;24H[1K (B[0;1m[33m"Map max_entries(%d) mismatch expected size(%d)\n"[39m(B[m,[31;24H[1K __func__, info->max_entries, exp->max_entries);[32;16H[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[33;8H[1K }[34d[1K (B[0;1m[33mif[39m(B[m (exp->type && exp->type  != info->type) {[30d[?25l[41;46H(B[0;7m[ Mark Unset ](B[m[1;99H(B[0;7m    (B[m[16;8H[1K (B[0;1m[33mif[39m(B[m (exp->key_size && exp->key_size != info->key_size) {[17;16H[1K fprintf(stderr, (B[0;1m[33m"ERR: %s() "[18;24H[39m(B[m[1K (B[0;1m[33m"Map key size(%d) mismatch expected size(%d)\n"[39m(B[m,[19;24H[1K __func__, info->key_size, exp->key_size);[20;16H[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[21;8H[1K }[22d[1K (B[0;1m[33mif[39m(B[m (exp->value_size && exp->value_size != info->value_size) {[23;16H[1K fprintf(stderr, (B[0;1m[33m"ERR: %s() "[24;24H[39m(B[m[1K (B[0;1m[33m"Map value size(%d) mismatch expected size(%d)\n"[39m(B[m,[25;24H[1K __func__, info->value_size, exp->value_size);[26;16H[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[27;8H[1K }[28d[1K (B[0;1m[33mif[39m(B[m (exp->max_entries && exp->max_entries != info->max_entries) {[29;16H[1K fprintf(stderr, (B[0;1m[33m"ERR: %s() "[30d[39m(B[m[?12l[?25h[?25l[?12l[?25h[25d[?25l[?12l[?25h[20d[?25l[?12l[?25h[15d[?25l[41d[K[?12l[?25h[10d[?25l[?12l[?25h[5d[?25l[?12l[?25h[2;40r[2;1H[2T[1;43r[2;32H[32mstruct[39m(B[m bpf_map_info *exp)[3d{[A[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[34m/* Lesson#4: It is userspace responsibility to known what map it is reading and[3d * know the value size. Here get bpf_map_info and check if it match our expected[4d * values.[5d */[6d(B[0m[32mstatic[39m(B[m [32mint[39m(B[m __check_map_fd_info([32mint[39m(B[m map_fd, [32mstruct[39m(B[m bpf_map_info *info,[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;17Hstats_print(&record, &prev);[3;17Hsleep(interval);[4;9H}[5d}[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9Husleep(1000000/4);[4;9H(B[0;1m[33mwhile[39m(B[m (1) {[5;17Hprev = record; (B[0;1m[34m/* struct copy */[6;17H[39m(B[mstats_collect(map_fd, map_type, &record);[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;17Hprintf((B[0;1m[33m"%-12s\n"[39m(B[m, (B[0;1m[33m"XDP-action"[39m(B[m);[3;9H}[5d(B[0;1m[34m/* Get initial reading quickly */[6;9H[39m(B[mstats_collect(map_fd, map_type, &record);[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9Hsetlocale((B[0;1m[31mLC_NUMERIC[39m(B[m, (B[0;1m[33m"en_US"[39m(B[m);[4;9H(B[0;1m[34m/* Print stats "header" */[5;9H[33mif[39m(B[m (verbose) {[6;17Hprintf((B[0;1m[33m"\n"[39m(B[m);[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H[32mstatic[39m(B[m [32mvoid[39m(B[m stats_poll([32mint[39m(B[m map_fd, __u32 map_type, [32mint[39m(B[m interval)[3d{[4;9H[32mstruct[39m(B[m stats_record prev, record = { 0 };[6;9H(B[0;1m[34m/* Trick to pretty printf with thousands separators use %' */[2d[39m(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;9H__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m;[4;9Hmap_collect(map_fd, map_type, key, &stats_rec->stats[0]);[5d}[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H[32mstatic[39m(B[m [32mvoid[39m(B[m stats_collect([32mint[39m(B[m map_fd, __u32 map_type,[4;27H[32mstruct[39m(B[m stats_record *stats_rec)[5d{[6;9H(B[0;1m[34m/* Assignment#2: Collect other XDP actions stats  */[2d[39m(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[3;9H(B[0;1m[34m/* Assignment#1: Add byte counters */[4;9H[39m(B[mrec->total.rx_packets = value.rx_packets;[5;9H[35mreturn[39m(B[m true;[6d}[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;17Hfprintf(stderr, (B[0;1m[33m"ERR: Unknown map_type(%u) cannot handle\n"[39m(B[m,[3;25Hmap_type);[4;17H[35mreturn[39m(B[m false;[5;17H[35mbreak[39m(B[m;[6;9H}[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;17Hmap_get_value_array(fd, key, &value);[3;17H[35mbreak[39m(B[m;[4;9H(B[0;1m[33mcase[39m(B[m (B[0;1m[31mBPF_MAP_TYPE_PERCPU_ARRAY(B[0m:[5;17H(B[0;1m[34m/* fall-through */[6;8H[35m[1K [33mdefault(B[0m:[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H(B[0;1m[34m/* Get time as close as possible to reading map contents */[3;9H[39m(B[mrec->timestamp = gettime();[5;9H(B[0;1m[33mswitch[39m(B[m (map_type) {[6;9H(B[0;1m[33mcase[39m(B[m (B[0;1m[31mBPF_MAP_TYPE_ARRAY(B[0m:[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H[32mstatic[39m(B[m [32mbool[39m(B[m map_collect([32mint[39m(B[m fd, __u32 map_type, __u32 key, [32mstruct[39m(B[m record *rec)[4d{[5;9H[32mstruct[39m(B[m datarec value;[2d[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;9H(B[0;1m[34m// unsigned int nr_cpus = libbpf_num_possible_cpus();[3;9H// struct datarec values[nr_cpus];[5;9H[39m(B[mfprintf(stderr, (B[0;1m[33m"ERR: %s() not impl. see assignment#3"[39m(B[m, __func__);[6d}[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H(B[0;1m[34m/* BPF_MAP_TYPE_PERCPU_ARRAY */[4d(B[0m[32mvoid[39m(B[m map_get_value_percpu_array([32mint[39m(B[m fd, __u32 key, [32mstruct[39m(B[m datarec *value)[5d{[6;9H(B[0;1m[34m/* For percpu maps, userspace gets a value per possible CPU */[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H(B[0;1m[33mif[39m(B[m ((bpf_map_lookup_elem(fd, &key, value)) != 0) {[3;17Hfprintf(stderr,[4;25H(B[0;1m[33m"ERR: bpf_map_lookup_elem failed key:0x%X\n"[39m(B[m, key);[5;9H}[6d}[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H}[4d(B[0;1m[34m/* BPF_MAP_TYPE_ARRAY */[5d(B[0m[32mvoid[39m(B[m map_get_value_array([32mint[39m(B[m fd, __u32 key, [32mstruct[39m(B[m datarec *value)[6d{[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;17Hpackets = rec->total.rx_packets - prev->total.rx_packets;[3;17Hpps     = packets / period;[5;17Hprintf(fmt, action, rec->total.rx_packets, pps, period);[6;9H}[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;17Hperiod = calc_period(rec, prev);[4;17H(B[0;1m[33mif[39m(B[m (period == 0)[5;24H[35mreturn[39m(B[m;[2d[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;25H(B[0;1m[34m//" %'11lld Kbytes (%'6.0f Mbits/s)"[3;25H[33m" period:%f\n"[39m(B[m;[4;17H[32mconst[39m(B[m [32mchar[39m(B[m *action = action2str((B[0;1m[31mXDP_PASS[39m(B[m);[5;17Hrec  = &stats_rec->stats[0];[6;17Hprev = &stats_prev->stats[0];[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H[32mdouble[39m(B[m pps; (B[0;1m[34m/* packets per sec */[4;9H/* Assignment#2: Print other XDP actions stats  */[5;9H[39m(B[m{[6;17H[32mchar[39m(B[m *fmt = (B[0;1m[33m"%-12s %'11lld pkts (%'10.0f pps)"[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;25H[32mstruct[39m(B[m stats_record *stats_prev)[3d{[4;9H[32mstruct[39m(B[m record *rec, *prev;[5;9H[32mdouble[39m(B[m period;[6;9H__u64 packets;[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;9H[35mreturn[39m(B[m period_;[4d}[6d[32mstatic[39m(B[m [32mvoid[39m(B[m stats_print([32mstruct[39m(B[m stats_record *stats_rec,[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H__u64 period = 0;[4;9Hperiod = r->timestamp - p->timestamp;[5;9H(B[0;1m[33mif[39m(B[m (period > 0)[6;17Hperiod_ = (([32mdouble[39m(B[m) period / (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m);[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H};[4d[32mstatic[39m(B[m [32mdouble[39m(B[m calc_period([32mstruct[39m(B[m record *r, [32mstruct[39m(B[m record *p)[5d{[6;9H[32mdouble[39m(B[m period_ = 0;[2d[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;9H[32mstruct[39m(B[m datarec total; (B[0;1m[34m/* defined in common_kern_user.h */[3d[39m(B[m};[5d[32mstruct[39m(B[m stats_record {[6;9H[32mstruct[39m(B[m record stats[1]; (B[0;1m[34m/* Assignment#2: Hint */[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H[35mreturn[39m(B[m (__u64) t.tv_sec * (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m + t.tv_nsec;[3d}[5d[32mstruct[39m(B[m record {[6;9H__u64 timestamp;[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9Hres = clock_gettime((B[0;1m[31mCLOCK_MONOTONIC[39m(B[m, &t);[3;9H(B[0;1m[33mif[39m(B[m (res < 0) {[4;17Hfprintf(stderr, (B[0;1m[33m"Error with gettimeofday! (%i)\n"[39m(B[m, res);[5;17Hexit((B[0;1m[31mEXIT_FAIL[39m(B[m);[6;9H}[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H[32mstatic[39m(B[m __u64 gettime([32mvoid[39m(B[m)[3d{[4;9H[32mstruct[39m(B[m timespec t;[5;9H[32mint[39m(B[m res;[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[35m out(B[0m:[3;9H[35mreturn[39m(B[m map_fd;[4d}[6d(B[0;1m[36m#define[39m(B[m (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m 1000000000 (B[0;1m[34m/* 10^9 */[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;17Hfprintf(stderr, (B[0;1m[33m"ERR: cannot find map by name: %s\n"[39m(B[m, mapname);[3;17H[35mgoto[39m(B[m out;[4;9H}[6dmap_fd = bpf_map__fd(map);[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H[32mint[39m(B[m map_fd = -1;[4;9H(B[0;1m[34m/* Lesson#3: bpf_object to bpf_map */[5;9H[39m(B[mmap = bpf_object__find_map_by_name(bpf_obj, mapname);[6;9H(B[0;1m[33mif[39m(B[m (!map) {[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H};[4d[32mint[39m(B[m find_map_fd([32mstruct[39m(B[m bpf_object *bpf_obj, [32mconst[39m(B[m [32mchar[39m(B[m *mapname)[5d{[6;9H[32mstruct[39m(B[m bpf_map *map;[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;9H{{(B[0;1m[33m"progname"[39m(B[m,    required_argument,     (B[0;1m[31mNULL[39m(B[m,  2  },[4;10H(B[0;1m[33m"Load program from function <name> in the ELF file"[39m(B[m, (B[0;1m[33m"<name>"[39m(B[m},[6;9H{{0, 0, (B[0;1m[31mNULL[39m(B[m,  0 }}[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H{{(B[0;1m[33m"quiet"[39m(B[m,[26Gno_argument,[2;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'q'[39m(B[m },[3;10H(B[0;1m[33m"Quiet mode (no output)"[39m(B[m},[5;9H{{(B[0;1m[33m"filename"[39m(B[m,    required_argument,     (B[0;1m[31mNULL[39m(B[m,  1  },[6;10H(B[0;1m[33m"Load program from <file>"[39m(B[m, (B[0;1m[33m"<file>"[39m(B[m},[2d[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;10H(B[0;1m[33m"Unload XDP program <id> instead of loading"[39m(B[m, (B[0;1m[33m"<id>"[39m(B[m},[4;9H{{(B[0;1m[33m"unload-all"[39m(B[m,  no_argument,[4;49H(B[0;1m[31mNULL[39m(B[m,  4  },[5;10H(B[0;1m[33m"Unload all XDP programs on device"[39m(B[m},[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;9H{{(B[0;1m[33m"auto-mode"[39m(B[m,   no_argument,[3;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'A'[39m(B[m },[4;10H(B[0;1m[33m"Auto-detect SKB or native mode"[39m(B[m},[6;9H{{(B[0;1m[33m"unload"[39m(B[m,[26Grequired_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'U'[39m(B[m },[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;9H{{(B[0;1m[33m"skb-mode"[39m(B[m,    no_argument,[2;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'S'[39m(B[m },[3;10H(B[0;1m[33m"Install XDP program in SKB (AKA generic) mode"[39m(B[m},[5;9H{{(B[0;1m[33m"native-mode"[39m(B[m, no_argument,[5;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'N'[39m(B[m },[6;10H(B[0;1m[33m"Install XDP program in native mode"[39m(B[m},[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;10H(B[0;1m[33m"Show help"[39m(B[m, false},[4;9H{{(B[0;1m[33m"dev"[39m(B[m,[4;26Hrequired_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'd'[39m(B[m },[5;10H(B[0;1m[33m"Operate on device <ifname>"[39m(B[m, (B[0;1m[33m"<ifname>"[39m(B[m, true},[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *default_filename = (B[0;1m[33m"xdp_prog_kern.o"[39m(B[m;[3d[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *default_progname = (B[0;1m[33m"xdp_stats1_func"[39m(B[m;[5d[32mstatic[39m(B[m [32mconst[39m(B[m [32mstruct[39m(B[m option_wrapper long_options[] = {[6;9H{{(B[0;1m[33m"help"[39m(B[m,[6;26Hno_argument,[6;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'h'[39m(B[m },[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H(B[0;1m[36m#include[39m(B[m (B[0;1m[33m"../common/common_params.h"[4d[36m#include[39m(B[m (B[0;1m[33m"../common/common_user_bpf_xdp.h"[5d[36m#include[39m(B[m (B[0;1m[33m"common_kern_user.h"[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[36m#include[33m <bpf/libbpf.h>[3d[36m#include[33m <xdp/libxdp.h>[5d[36m#include[33m <net/if.h>[6d[36m#include[33m <linux/if_link.h>[39m(B[m (B[0;1m[34m/* depend on kernel-headers installed */[2d[39m(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H(B[0;1m[36m#include[33m <locale.h>[3d[36m#include[33m <unistd.h>[4d[36m#include[33m <time.h>[6d[36m#include[33m <bpf/bpf.h>[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[36m#include[33m <stdlib.h>[3d[36m#include[33m <string.h>[4d[36m#include[33m <errno.h>[5d[36m#include[33m <getopt.h>[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d(B[0m[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *__doc__ = (B[0;1m[33m"XDP loader and stats program\n"[4;9H" - Allows selecting BPF --progname name to XDP-attach to --dev\n"[39m(B[m;[6d(B[0;1m[36m#include[33m <stdio.h>[2d[39m(B[m[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[41;47H(B[0;7m[ Mark Set ](B[m[1;99H(B[0;7mM   (B[m[?12l[?25h[2d[?25l[?12l[?25h(B[0;7m/* SPDX-License-Identifier: GPL-2.0 */[3dstatic const char *__doc__ = "XDP loader and stats program\n"[4d        " - Allows selecting BPF --progname name to XDP-attach to --dev\n";[6d#include <stdio.h>[7d(B[m[?25l[?12l[?25h(B[0;7m#include <stdlib.h>[8d#include <string.h>[9d#include <errno.h>[10d#include <getopt.h>[12d(B[m[?25l[?12l[?25h(B[0;7m#include <locale.h>[13d#include <unistd.h>[14d#include <time.h>[16d#include <bpf/bpf.h>[17d(B[m[?25l[41d[K[?12l[?25h[17d(B[0;7m#include <bpf/libbpf.h>[18d#include <xdp/libxdp.h>[20d#include <net/if.h>[21d#include <linux/if_link.h> /* depend on kernel-headers installed */[22d(B[m[?25l[?12l[?25h[23d(B[0;7m#include "../common/common_params.h"[24d#include "../common/common_user_bpf_xdp.h"[25d#include "common_kern_user.h"[27d(B[m[?25l[?12l[?25h(B[0;7mstatic const char *default_filename = "xdp_prog_kern.o";[28dstatic const char *default_progname = "xdp_stats1_func";[30dstatic const struct option_wrapper long_options[] = {[31d        {{"help",        no_argument,           NULL, 'h' },[32d(B[m[?25l[?12l[?25h(B[0;7m         "Show help", false},[34d        {{"dev",         required_argument,     NULL, 'd' },[35d         "Operate on device <ifname>", "<ifname>", true},[37d(B[m[?25l[?12l[?25h[2;41r[41;1H[2S[1;43r[35;1H(B[0;7m        {{"skb-mode",    no_argument,           NULL, 'S' },[36d         "Install XDP program in SKB (AKA generic) mode"},[38d        {{"native-mode", no_argument,           NULL, 'N' },[39d         "Install XDP program in native mode"},[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;7m        {{"auto-mode",   no_argument,           NULL, 'A' },[37d         "Auto-detect SKB or native mode"},[39d        {{"unload",      required_argument,     NULL, 'U' },[40;10H(B[0;1m[33m"Unload XDP program <id> instead of loading"[39m(B[m, (B[0;1m[33m"<id>"[39m(B[m},[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m         "Unload XDP program <id> instead of loading", "<id>"},[37d        {{"unload-all",  no_argument,           NULL,  4  },[38d         "Unload all XDP programs on device"},[40;9H(B[m{{(B[0;1m[33m"quiet"[39m(B[m,[26Gno_argument,[40;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'q'[39m(B[m },[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        {{"quiet",       no_argument,           NULL, 'q' },[36d         "Quiet mode (no output)"},[38d        {{"filename",    required_argument,     NULL,  1  },[39d         "Load program from <file>", "<file>"},[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;7m        {{"progname",    required_argument,     NULL,  2  },[37d         "Load program from function <name> in the ELF file", "<name>"},[39d        {{0, 0, NULL,  0 }}[40d(B[m};[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m};[37dint find_map_fd(struct bpf_object *bpf_obj, const char *mapname)[38d{[39d        struct bpf_map *map;[40;9H(B[0m[32mint[39m(B[m map_fd = -1;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        int map_fd = -1;[37d        /* Lesson#3: bpf_object to bpf_map */[38d        map = bpf_object__find_map_by_name(bpf_obj, mapname);[39d        if (!map) {[40;17H(B[mfprintf(stderr, (B[0;1m[33m"ERR: cannot find map by name: %s\n"[39m(B[m, mapname);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                fprintf(stderr, "ERR: cannot find map by name: %s\n", mapname);[36d                goto out;[37d        }[39d        map_fd = bpf_map__fd(map);[40d(B[0;1m[35m out(B[0m:(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m out:[36d        return map_fd;[37d}[39d#define NANOSEC_PER_SEC 1000000000 /* 10^9 */[40d(B[0m[32mstatic[39m(B[m __u64 gettime([32mvoid[39m(B[m)[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7mstatic __u64 gettime(void)[36d{[37d        struct timespec t;[38d        int res;[40;9H(B[mres = clock_gettime((B[0;1m[31mCLOCK_MONOTONIC[39m(B[m, &t);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        res = clock_gettime(CLOCK_MONOTONIC, &t);[36d        if (res < 0) {[37d                fprintf(stderr, "Error with gettimeofday! (%i)\n", res);[38d                exit(EXIT_FAIL);[39d        }[40d(B[0m[35mreturn[39m(B[m (__u64) t.tv_sec * (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m + t.tv_nsec;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        return (__u64) t.tv_sec * NANOSEC_PER_SEC + t.tv_nsec;[36d}[38dstruct record {[39d        __u64 timestamp;[40;9H(B[0m[32mstruct[39m(B[m datarec total; (B[0;1m[34m/* defined in common_kern_user.h */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        struct datarec total; /* defined in common_kern_user.h */[36d};[38dstruct stats_record {[39d        struct record stats[1]; /* Assignment#2: Hint */[40d(B[m};[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m};[37dstatic double calc_period(struct record *r, struct record *p)[38d{[39d        double period_ = 0;[40;9H(B[m__u64 period = 0;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        __u64 period = 0;[37d        period = r->timestamp - p->timestamp;[38d        if (period > 0)[39d                period_ = ((double) period / NANOSEC_PER_SEC);[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;7m        return period_;[37d}[39dstatic void stats_print(struct stats_record *stats_rec,[40;25H(B[0m[32mstruct[39m(B[m stats_record *stats_prev)[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                        struct stats_record *stats_prev)[36d{[37d        struct record *rec, *prev;[38d        double period;[39d        __u64 packets;[40;9H(B[0m[32mdouble[39m(B[m pps; (B[0;1m[34m/* packets per sec */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        double pps; /* packets per sec */[37d        /* Assignment#2: Print other XDP actions stats  */[38d        {[39d                char *fmt = "%-12s %'11lld pkts (%'10.0f pps)"[40;25H(B[0;1m[34m//" %'11lld Kbytes (%'6.0f Mbits/s)"[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                        //" %'11lld Kbytes (%'6.0f Mbits/s)"[36d                        " period:%f\n";[37d                const char *action = action2str(XDP_PASS);[38d                rec  = &stats_rec->stats[0];[39d                prev = &stats_prev->stats[0];[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;7m                period = calc_period(rec, prev);[37d                if (period == 0)[38d                       return;[40;17H(B[mpackets = rec->total.rx_packets - prev->total.rx_packets;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                packets = rec->total.rx_packets - prev->total.rx_packets;[36d                pps     = packets / period;[38d                printf(fmt, action, rec->total.rx_packets, pps, period);[39d        }[40d(B[m}[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m}[37d/* BPF_MAP_TYPE_ARRAY */[38dvoid map_get_value_array(int fd, __u32 key, struct datarec *value)[39d{[40;9H(B[0;1m[33mif[39m(B[m ((bpf_map_lookup_elem(fd, &key, value)) != 0) {[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        if ((bpf_map_lookup_elem(fd, &key, value)) != 0) {[36d                fprintf(stderr,[37d                        "ERR: bpf_map_lookup_elem failed key:0x%X\n", key);[38d        }[39d}[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;7m/* BPF_MAP_TYPE_PERCPU_ARRAY */[37dvoid map_get_value_percpu_array(int fd, __u32 key, struct datarec *value)[38d{[39d        /* For percpu maps, userspace gets a value per possible CPU */[40;9H(B[0;1m[34m// unsigned int nr_cpus = libbpf_num_possible_cpus();[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        // unsigned int nr_cpus = libbpf_num_possible_cpus();[36d        // struct datarec values[nr_cpus];[38d        fprintf(stderr, "ERR: %s() not impl. see assignment#3", __func__);[39d}[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;7mstatic bool map_collect(int fd, __u32 map_type, __u32 key, struct record *rec)[37d{[38d        struct datarec value;[40;9H(B[0;1m[34m/* Get time as close as possible to reading map contents */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        /* Get time as close as possible to reading map contents */[36d        rec->timestamp = gettime();[38d        switch (map_type) {[39d        case BPF_MAP_TYPE_ARRAY:[40;17H(B[mmap_get_value_array(fd, key, &value);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                map_get_value_array(fd, key, &value);[36d                break;[37d        case BPF_MAP_TYPE_PERCPU_ARRAY:[38d                /* fall-through */[39d        default:[40d(B[mfprintf(stderr, (B[0;1m[33m"ERR: Unknown map_type(%u) cannot handle\n"[39m(B[m,[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                fprintf(stderr, "ERR: Unknown map_type(%u) cannot handle\n",[36d                        map_type);[37d                return false;[38d                break;[39d        }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;7m        /* Assignment#1: Add byte counters */[37d        rec->total.rx_packets = value.rx_packets;[38d        return true;[39d}[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;7mstatic void stats_collect(int map_fd, __u32 map_type,[37d                          struct stats_record *stats_rec)[38d{[39d        /* Assignment#2: Collect other XDP actions stats  */[40;9H(B[m__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        __u32 key = XDP_PASS;[37d        map_collect(map_fd, map_type, key, &stats_rec->stats[0]);[38d}[40d(B[0m[32mstatic[39m(B[m [32mvoid[39m(B[m stats_poll([32mint[39m(B[m map_fd, __u32 map_type, [32mint[39m(B[m interval)[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7mstatic void stats_poll(int map_fd, __u32 map_type, int interval)[36d{[37d        struct stats_record prev, record = { 0 };[39d        /* Trick to pretty printf with thousands separators use %' */[40;9H(B[msetlocale((B[0;1m[31mLC_NUMERIC[39m(B[m, (B[0;1m[33m"en_US"[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        setlocale(LC_NUMERIC, "en_US");[37d        /* Print stats "header" */[38d        if (verbose) {[39d                printf("\n");[40;17H(B[mprintf((B[0;1m[33m"%-12s\n"[39m(B[m, (B[0;1m[33m"XDP-action"[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                printf("%-12s\n", "XDP-action");[36d        }[38d        /* Get initial reading quickly */[39d        stats_collect(map_fd, map_type, &record);[40;9H(B[musleep(1000000/4);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        usleep(1000000/4);[37d        while (1) {[38d                prev = record; /* struct copy */[39d                stats_collect(map_fd, map_type, &record);[40;17H(B[mstats_print(&record, &prev);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                stats_print(&record, &prev);[36d                sleep(interval);[37d        }[38d}[40d(B[0;1m[34m/* Lesson#4: It is userspace responsibility to known what map it is reading and[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m/* Lesson#4: It is userspace responsibility to known what map it is reading and[36d * know the value size. Here get bpf_map_info and check if it match our expected[37d * values.[38d */[39dstatic int __check_map_fd_info(int map_fd, struct bpf_map_info *info,[40;32H(B[0m[32mstruct[39m(B[m bpf_map_info *exp)[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                               struct bpf_map_info *exp)[36d{[37d        __u32 info_len = sizeof(*info);[38d        int err;[40;9H(B[0;1m[33mif[39m(B[m (map_fd < 0)[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        if (map_fd < 0)[36d                return EXIT_FAIL;[38d        /* BPF-info via bpf-syscall */[39d        err = bpf_obj_get_info_by_fd(map_fd, info, &info_len);[40;9H(B[0;1m[33mif[39m(B[m (err) {[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        if (err) {[36d                fprintf(stderr, "ERR: %s() can't get info - %s\n",[37d                        __func__,  strerror(errno));[38d                return EXIT_FAIL_BPF;[39d        }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;7m        if (exp->key_size && exp->key_size != info->key_size) {[37d                fprintf(stderr, "ERR: %s() "[38d                        "Map key size(%d) mismatch expected size(%d)\n",[39d                        __func__, info->key_size, exp->key_size);[40;17H(B[0m[35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                return EXIT_FAIL;[36d        }[37d        if (exp->value_size && exp->value_size != info->value_size) {[38d                fprintf(stderr, "ERR: %s() "[39d                        "Map value size(%d) mismatch expected size(%d)\n",[40;25H(B[m__func__, info->value_size, exp->value_size);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                        __func__, info->value_size, exp->value_size);[36d                return EXIT_FAIL;[37d        }[38d        if (exp->max_entries && exp->max_entries != info->max_entries) {[39d                fprintf(stderr, "ERR: %s() "[40;25H(B[0;1m[33m"Map max_entries(%d) mismatch expected size(%d)\n"[39m(B[m,[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                        "Map max_entries(%d) mismatch expected size(%d)\n",[36d                        __func__, info->max_entries, exp->max_entries);[37d                return EXIT_FAIL;[38d        }[39d        if (exp->type && exp->type  != info->type) {[40;17H(B[mfprintf(stderr, (B[0;1m[33m"ERR: %s() "[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                fprintf(stderr, "ERR: %s() "[36d                        "Map type(%d) mismatch expected type(%d)\n",[37d                        __func__, info->type, exp->type);[38d                return EXIT_FAIL;[39d        }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;7m        return 0;[37d}[39dint main(int argc, char **argv)[40d(B[m{[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m{[36d        struct bpf_map_info map_expect = { 0 };[37d        struct bpf_map_info info = { 0 };[38d        struct xdp_program *program;[39d        int stats_map_fd;[40;9H(B[0m[32mint[39m(B[m interval = 2;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        int interval = 2;[36d        char errmsg[1024];[37d        int err;[39d        struct config cfg = {[40;17H(B[m.ifindex   = -1,[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                .ifindex   = -1,[36d                .do_unload = false,[37d        };[38d        /* Set default BPF-ELF object file and BPF program name */[39d        strncpy(cfg.filename, default_filename, sizeof(cfg.filename));[40;9H(B[mstrncpy(cfg.progname,  default_progname,  [32msizeof[39m(B[m(cfg.progname));[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        strncpy(cfg.progname,  default_progname,  sizeof(cfg.progname));[36d        /* Cmdline options can change progname */[37d        parse_cmdline_args(argc, argv, long_options, &cfg, __doc__);[39d        /* Required option */[40;9H(B[0;1m[33mif[39m(B[m (cfg.ifindex == -1) {[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        if (cfg.ifindex == -1) {[36d                fprintf(stderr, "ERR: required option --dev missing\n");[37d                usage(argv[0], __doc__, long_options, (argc == 1));[38d                return EXIT_FAIL_OPTION;[39d        }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;7m        /* Unload a program by prog_id, or[37d         * unload all programs on net device[38d         */[39d        if (cfg.do_unload || cfg.unload_all) {[40;17H(B[merr = do_unload(&cfg);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                err = do_unload(&cfg);[36d                if (err) {[37d                        libxdp_strerror(err, errmsg, sizeof(errmsg));[38d                        fprintf(stderr, "Couldn't unload XDP program %d: %s\n",[39d                                cfg.prog_id, errmsg);[40;25H(B[0m[35mreturn[39m(B[m err;[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                        return err;[36d                }[38d                printf("Success: Unloading XDP prog name: %s\n", cfg.progname);[39d                return EXIT_OK;[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        }[37d        program = load_bpf_and_xdp_attach(&cfg);[38d        if (!program)[39d                return EXIT_FAIL_BPF;[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;7m        if (verbose) {[37d                printf("Success: Loaded BPF-object(%s) and used section(%s)\n",[38d                       cfg.filename, cfg.progname);[39d                printf(" - XDP prog id:%d attached on device:%s(ifindex:%d)\n",[40;24H(B[mxdp_program__id(program), cfg.ifname, cfg.ifindex);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                       xdp_program__id(program), cfg.ifname, cfg.ifindex);[36d        }[38d        /* Lesson#3: Locate map file descriptor */[39d        stats_map_fd = find_map_fd(xdp_program__bpf_obj(program), "xdp_stats_map");[40;9H(B[0;1m[33mif[39m(B[m (stats_map_fd < 0) {[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        if (stats_map_fd < 0) {[36d                /* xdp_link_detach(cfg.ifindex, cfg.xdp_flags, 0); */[37d                return EXIT_FAIL_BPF;[38d        }[40d(B[0;1m[34m/* Lesson#4: check map info, e.g. datarec is expected size */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        /* Lesson#4: check map info, e.g. datarec is expected size */[36d        map_expect.key_size    = sizeof(__u32);[37d        map_expect.value_size  = sizeof(struct datarec);[38d        map_expect.max_entries = XDP_ACTION_MAX;[39d        err = __check_map_fd_info(stats_map_fd, &info, &map_expect);[40;9H(B[0;1m[33mif[39m(B[m (err) {[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        if (err) {[36d                fprintf(stderr, "ERR: map via FD not compatible\n");[37d                return err;[38d        }[39d        if (verbose) {[40;17H(B[mprintf((B[0;1m[33m"\nCollecting stats from BPF map\n"[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                printf("\nCollecting stats from BPF map\n");[36d                printf(" - BPF map (bpf_map_type:%d) id:%d name:%s"[37d                       " key_size:%d value_size:%d max_entries:%d\n",[38d                       info.type, info.id, info.name,[39d                       info.key_size, info.value_size, info.max_entries[40;24H(B[m);[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m                       );[36d        }[38d        stats_poll(stats_map_fd, info.type, interval);[39d        return EXIT_OK;[40d(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m}[40d(B[m[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[41;46H(B[0;7m[ Mark Unset ](B[m[1;99H(B[0;7m    (B[m[2;8H[1K (B[0;1m[33mif[39m(B[m (!program)[3;16H[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL_BPF[39m(B[m;[5;8H[1K (B[0;1m[33mif[39m(B[m (verbose) {[6;16H[1K printf((B[0;1m[33m"Success: Loaded BPF-object(%s) and used section(%s)\n"[39m(B[m,[7;23H[1K cfg.filename, cfg.progname);[8;16H[1K printf((B[0;1m[33m" - XDP prog id:%d attached on device:%s(ifindex:%d)\n"[39m(B[m,[9;23H[1K xdp_program__id(program), cfg.ifname, cfg.ifindex);[10;8H[1K }[12d[1K (B[0;1m[34m/* Lesson#3: Locate map file descriptor */[13;8H[39m(B[m[1K stats_map_fd = find_map_fd(xdp_program__bpf_obj(program), (B[0;1m[33m"xdp_stats_map"[39m(B[m);[14;8H[1K (B[0;1m[33mif[39m(B[m (stats_map_fd < 0) {[15;16H[1K (B[0;1m[34m/* xdp_link_detach(cfg.ifindex, cfg.xdp_flags, 0); */[16;16H[39m(B[m[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL_BPF[39m(B[m;[17;8H[1K }[19d[1K (B[0;1m[34m/* Lesson#4: check map info, e.g. datarec is expected size */[20;8H[39m(B[m[1K map_expect.key_size    = [32msizeof[39m(B[m(__u32);[21;8H[1K map_expect.value_size  = [32msizeof[39m(B[m([32mstruct[39m(B[m datarec);[22;8H[1K map_expect.max_entries = (B[0;1m[31mXDP_ACTION_MAX[39m(B[m;[23;8H[1K err = __check_map_fd_info(stats_map_fd, &info, &map_expect);[24;8H[1K (B[0;1m[33mif[39m(B[m (err) {[25;16H[1K fprintf(stderr, (B[0;1m[33m"ERR: map via FD not compatible\n"[39m(B[m);[26;16H[1K [35mreturn[39m(B[m err;[27;8H[1K }[28d[1K (B[0;1m[33mif[39m(B[m (verbose) {[29;16H[1K printf((B[0;1m[33m"\nCollecting stats from BPF map\n"[39m(B[m);[30;16H[1K printf((B[0;1m[33m" - BPF map (bpf_map_type:%d) id:%d name:%s"[31;23H[39m(B[m[1K (B[0;1m[33m" key_size:%d value_size:%d max_entries:%d\n"[39m(B[m,[32;23H[1K info.type, info.id, info.name,[33;23H[1K info.key_size, info.value_size, info.max_entries[34;23H[1K );[35;8H[1K }[37d[1K stats_poll(stats_map_fd, info.type, interval);[38;8H[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_OK[39m(B[m;[39d}[40d[?12l[?25h[?25l[41;46H (B[0;7m[ Mark Set ](B[m[K[1;99H(B[0;7mM   (B[m[?12l[?25h[40d[?25l[?12l[?25h[35d(B[0;7m        }[37d        stats_poll(stats_map_fd, info.type, interval);[38d        return EXIT_OK;[39d}[35d(B[m[?25l[?12l[?25h[30d(B[0;7m                printf(" - BPF map (bpf_map_type:%d) id:%d name:%s"[31d                       " key_size:%d value_size:%d max_entries:%d\n",[32d                       info.type, info.id, info.name,[33d                       info.key_size, info.value_size, info.max_entries[34d                       );[30d(B[m[?25l[?12l[?25h[25d(B[0;7m                fprintf(stderr, "ERR: map via FD not compatible\n");[26d                return err;[27d        }[28d        if (verbose) {[29d                printf("\nCollecting stats from BPF map\n");[25d(B[m[?25l[41d[K[?12l[?25h[20d(B[0;7m        map_expect.key_size    = sizeof(__u32);[21d        map_expect.value_size  = sizeof(struct datarec);[22d        map_expect.max_entries = XDP_ACTION_MAX;[23d        err = __check_map_fd_info(stats_map_fd, &info, &map_expect);[24d        if (err) {[20d(B[m[?25l[?12l[?25h[15d(B[0;7m                /* xdp_link_detach(cfg.ifindex, cfg.xdp_flags, 0); */[16d                return EXIT_FAIL_BPF;[17d        }[19d        /* Lesson#4: check map info, e.g. datarec is expected size */[15d(B[m[?25l[?12l[?25h[10d(B[0;7m        }[12d        /* Lesson#3: Locate map file descriptor */[13d        stats_map_fd = find_map_fd(xdp_program__bpf_obj(program), "xdp_stats_map");[14d        if (stats_map_fd < 0) {[10d(B[m[?25l[?12l[?25h[5d(B[0;7m        if (verbose) {[6d                printf("Success: Loaded BPF-object(%s) and used section(%s)\n",[7d                       cfg.filename, cfg.progname);[8d                printf(" - XDP prog id:%d attached on device:%s(ifindex:%d)\n",[9d                       xdp_program__id(program), cfg.ifname, cfg.ifindex);[5d(B[m[?25l[?12l[?25h[2;40r[2;1H[2T[1;43r[3;1H(B[0;7m        program = load_bpf_and_xdp_attach(&cfg);[4d        if (!program)[5d                return EXIT_FAIL_BPF;[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m                }[4d                printf("Success: Unloading XDP prog name: %s\n", cfg.progname);[5d                return EXIT_OK;[6d        }[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m                if (err) {[3d                        libxdp_strerror(err, errmsg, sizeof(errmsg));[4d                        fprintf(stderr, "Couldn't unload XDP program %d: %s\n",[5d                                cfg.prog_id, errmsg);[6d                        return err;[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m        /* Unload a program by prog_id, or[3d         * unload all programs on net device[4d         */[5d        if (cfg.do_unload || cfg.unload_all) {[6d                err = do_unload(&cfg);[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m                fprintf(stderr, "ERR: required option --dev missing\n");[3d                usage(argv[0], __doc__, long_options, (argc == 1));[4d                return EXIT_FAIL_OPTION;[5d        }[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m        /* Cmdline options can change progname */[3d        parse_cmdline_args(argc, argv, long_options, &cfg, __doc__);[5d        /* Required option */[6d        if (cfg.ifindex == -1) {[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m                .do_unload = false,[3d        };[4d        /* Set default BPF-ELF object file and BPF program name */[5d        strncpy(cfg.filename, default_filename, sizeof(cfg.filename));[6d        strncpy(cfg.progname,  default_progname,  sizeof(cfg.progname));[2d(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H(B[0;7m        char errmsg[1024];[3d        int err;[5d        struct config cfg = {[6d                .ifindex   = -1,[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m        struct bpf_map_info map_expect = { 0 };[3d        struct bpf_map_info info = { 0 };[4d        struct xdp_program *program;[5d        int stats_map_fd;[6d        int interval = 2;[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m        return 0;[3d}[5dint main(int argc, char **argv)[6d{[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m                        "Map type(%d) mismatch expected type(%d)\n",[3d                        __func__, info->type, exp->type);[4d                return EXIT_FAIL;[5d        }[2d(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H(B[0;7m                        __func__, info->max_entries, exp->max_entries);[3d                return EXIT_FAIL;[4d        }[5d        if (exp->type && exp->type  != info->type) {[6d                fprintf(stderr, "ERR: %s() "[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m                return EXIT_FAIL;[3d        }[4d        if (exp->max_entries && exp->max_entries != info->max_entries) {[5d                fprintf(stderr, "ERR: %s() "[6d                        "Map max_entries(%d) mismatch expected size(%d)\n",[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m        }[3d        if (exp->value_size && exp->value_size != info->value_size) {[4d                fprintf(stderr, "ERR: %s() "[5d                        "Map value size(%d) mismatch expected size(%d)\n",[6d                        __func__, info->value_size, exp->value_size);[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m        if (exp->key_size && exp->key_size != info->key_size) {[3d                fprintf(stderr, "ERR: %s() "[4d                        "Map key size(%d) mismatch expected size(%d)\n",[5d                        __func__, info->key_size, exp->key_size);[6d                return EXIT_FAIL;[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m                fprintf(stderr, "ERR: %s() can't get info - %s\n",[3d                        __func__,  strerror(errno));[4d                return EXIT_FAIL_BPF;[5d        }[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m                return EXIT_FAIL;[4d        /* BPF-info via bpf-syscall */[5d        err = bpf_obj_get_info_by_fd(map_fd, info, &info_len);[6d        if (err) {[2d(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H(B[0;7m{[3d        __u32 info_len = sizeof(*info);[4d        int err;[6d        if (map_fd < 0)[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m * know the value size. Here get bpf_map_info and check if it match our expected[3d * values.[4d */[5dstatic int __check_map_fd_info(int map_fd, struct bpf_map_info *info,[6d                               struct bpf_map_info *exp)[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m                sleep(interval);[3d        }[4d}[6d/* Lesson#4: It is userspace responsibility to known what map it is reading and[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H(B[0;7m        while (1) {[4d                prev = record; /* struct copy */[5d                stats_collect(map_fd, map_type, &record);[6d                stats_print(&record, &prev);[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m        }[4d        /* Get initial reading quickly */[5d        stats_collect(map_fd, map_type, &record);[6d        usleep(1000000/4);[2d(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[3;1H(B[0;7m        /* Print stats "header" */[4d        if (verbose) {[5d                printf("\n");[6d                printf("%-12s\n", "XDP-action");[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m{[3d        struct stats_record prev, record = { 0 };[5d        /* Trick to pretty printf with thousands separators use %' */[6d        setlocale(LC_NUMERIC, "en_US");[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H(B[0;7m        map_collect(map_fd, map_type, key, &stats_rec->stats[0]);[4d}[6dstatic void stats_poll(int map_fd, __u32 map_type, int interval)[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7mstatic void stats_collect(int map_fd, __u32 map_type,[3d                          struct stats_record *stats_rec)[4d{[5d        /* Assignment#2: Collect other XDP actions stats  */[6d        __u32 key = XDP_PASS;[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m        /* Assignment#1: Add byte counters */[3d        rec->total.rx_packets = value.rx_packets;[4d        return true;[5d}[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m                        map_type);[3d                return false;[4d                break;[5d        }[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m                break;[3d        case BPF_MAP_TYPE_PERCPU_ARRAY:[4d                /* fall-through */[5d        default:[6d                fprintf(stderr, "ERR: Unknown map_type(%u) cannot handle\n",[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m        rec->timestamp = gettime();[4d        switch (map_type) {[5d        case BPF_MAP_TYPE_ARRAY:[6d                map_get_value_array(fd, key, &value);[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7mstatic bool map_collect(int fd, __u32 map_type, __u32 key, struct record *rec)[3d{[4d        struct datarec value;[6d        /* Get time as close as possible to reading map contents */[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m        // struct datarec values[nr_cpus];[4d        fprintf(stderr, "ERR: %s() not impl. see assignment#3", __func__);[5d}[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m/* BPF_MAP_TYPE_PERCPU_ARRAY */[3dvoid map_get_value_percpu_array(int fd, __u32 key, struct datarec *value)[4d{[5d        /* For percpu maps, userspace gets a value per possible CPU */[6d        // unsigned int nr_cpus = libbpf_num_possible_cpus();[2d(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H(B[0;7m                fprintf(stderr,[3d                        "ERR: bpf_map_lookup_elem failed key:0x%X\n", key);[4d        }[5d}[2d(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[3;1H(B[0;7m/* BPF_MAP_TYPE_ARRAY */[4dvoid map_get_value_array(int fd, __u32 key, struct datarec *value)[5d{[6d        if ((bpf_map_lookup_elem(fd, &key, value)) != 0) {[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m                pps     = packets / period;[4d                printf(fmt, action, rec->total.rx_packets, pps, period);[5d        }[6d}[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m                period = calc_period(rec, prev);[3d                if (period == 0)[4d                       return;[6d                packets = rec->total.rx_packets - prev->total.rx_packets;[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m                        " period:%f\n";[3d                const char *action = action2str(XDP_PASS);[4d                rec  = &stats_rec->stats[0];[5d                prev = &stats_prev->stats[0];[2d(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[3;1H(B[0;7m        /* Assignment#2: Print other XDP actions stats  */[4d        {[5d                char *fmt = "%-12s %'11lld pkts (%'10.0f pps)"[6d                        //" %'11lld Kbytes (%'6.0f Mbits/s)"[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m{[3d        struct record *rec, *prev;[4d        double period;[5d        __u64 packets;[6d        double pps; /* packets per sec */[2d(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H(B[0;7m        return period_;[3d}[5dstatic void stats_print(struct stats_record *stats_rec,[6d                        struct stats_record *stats_prev)[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H(B[0;7m        period = r->timestamp - p->timestamp;[4d        if (period > 0)[5d                period_ = ((double) period / NANOSEC_PER_SEC);[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H(B[0;7mstatic double calc_period(struct record *r, struct record *p)[4d{[5d        double period_ = 0;[6d        __u64 period = 0;[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m};[4dstruct stats_record {[5d        struct record stats[1]; /* Assignment#2: Hint */[6d};[2d(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H(B[0;7m}[4dstruct record {[5d        __u64 timestamp;[6d        struct datarec total; /* defined in common_kern_user.h */[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m        if (res < 0) {[3d                fprintf(stderr, "Error with gettimeofday! (%i)\n", res);[4d                exit(EXIT_FAIL);[5d        }[6d        return (__u64) t.tv_sec * NANOSEC_PER_SEC + t.tv_nsec;[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m{[3d        struct timespec t;[4d        int res;[6d        res = clock_gettime(CLOCK_MONOTONIC, &t);[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m        return map_fd;[3d}[5d#define NANOSEC_PER_SEC 1000000000 /* 10^9 */[6dstatic __u64 gettime(void)[2d(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H(B[0;7m                goto out;[3d        }[5d        map_fd = bpf_map__fd(map);[6d out:[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H(B[0;7m        /* Lesson#3: bpf_object to bpf_map */[4d        map = bpf_object__find_map_by_name(bpf_obj, mapname);[5d        if (!map) {[6d                fprintf(stderr, "ERR: cannot find map by name: %s\n", mapname);[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H(B[0;7mint find_map_fd(struct bpf_object *bpf_obj, const char *mapname)[4d{[5d        struct bpf_map *map;[6d        int map_fd = -1;[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m        {{"progname",    required_argument,     NULL,  2  },[3d         "Load program from function <name> in the ELF file", "<name>"},[5d        {{0, 0, NULL,  0 }}[6d};[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m         "Quiet mode (no output)"},[4d        {{"filename",    required_argument,     NULL,  1  },[5d         "Load program from <file>", "<file>"},[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H(B[0;7m        {{"unload-all",  no_argument,           NULL,  4  },[4d         "Unload all XDP programs on device"},[6d        {{"quiet",       no_argument,           NULL, 'q' },[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m        {{"auto-mode",   no_argument,           NULL, 'A' },[3d         "Auto-detect SKB or native mode"},[5d        {{"unload",      required_argument,     NULL, 'U' },[6d         "Unload XDP program <id> instead of loading", "<id>"},[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m         "Install XDP program in SKB (AKA generic) mode"},[4d        {{"native-mode", no_argument,           NULL, 'N' },[5d         "Install XDP program in native mode"},[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H(B[0;7m        {{"dev",         required_argument,     NULL, 'd' },[4d         "Operate on device <ifname>", "<ifname>", true},[6d        {{"skb-mode",    no_argument,           NULL, 'S' },[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7mstatic const char *default_progname = "xdp_stats1_func";[4dstatic const struct option_wrapper long_options[] = {[5d        {{"help",        no_argument,           NULL, 'h' },[6d         "Show help", false},[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m#include "../common/common_params.h"[3d#include "../common/common_user_bpf_xdp.h"[4d#include "common_kern_user.h"[6dstatic const char *default_filename = "xdp_prog_kern.o";[2d(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H(B[0;7m#include <xdp/libxdp.h>[4d#include <net/if.h>[5d#include <linux/if_link.h> /* depend on kernel-headers installed */[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m#include <unistd.h>[3d#include <time.h>[5d#include <bpf/bpf.h>[6d#include <bpf/libbpf.h>[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m#include <string.h>[3d#include <errno.h>[4d#include <getopt.h>[6d#include <locale.h>[2d(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H(B[0;7mstatic const char *__doc__ = "XDP loader and stats program\n"[3d        " - Allows selecting BPF --progname name to XDP-attach to --dev\n";[5d#include <stdio.h>[6d#include <stdlib.h>[2d(B[m[?25l[?12l[?25h7[2;40r8M[1;43r[2;1H(B[0;7m/* SPDX-License-Identifier: GPL-2.0 */(B[m[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[1;99H(B[0;7m    (B[m[2d(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d(B[0m[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *__doc__ = (B[0;1m[33m"XDP loader and stats program\n"[4;8H[39m(B[m[1K (B[0;1m[33m" - Allows selecting BPF --progname name to XDP-attach to --dev\n"[39m(B[m;[6d(B[0;1m[36m#include[33m <stdio.h>[7d[36m#include[33m <stdlib.h>[8d[36m#include[33m <string.h>[9d[36m#include[33m <errno.h>[10d[36m#include[33m <getopt.h>[12d[36m#include[33m <locale.h>[13d[36m#include[33m <unistd.h>[14d[36m#include[33m <time.h>[16d[36m#include[33m <bpf/bpf.h>[17d[36m#include[33m <bpf/libbpf.h>[18d[36m#include[33m <xdp/libxdp.h>[20d[36m#include[33m <net/if.h>[21d[36m#include[33m <linux/if_link.h>[39m(B[m (B[0;1m[34m/* depend on kernel-headers installed */[23d[36m#include[39m(B[m (B[0;1m[33m"../common/common_params.h"[24d[36m#include[39m(B[m (B[0;1m[33m"../common/common_user_bpf_xdp.h"[25d[36m#include[39m(B[m (B[0;1m[33m"common_kern_user.h"[27d(B[0m[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *default_filename = (B[0;1m[33m"xdp_prog_kern.o"[39m(B[m;[28d[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *default_progname = (B[0;1m[33m"xdp_stats1_func"[39m(B[m;[30d[32mstatic[39m(B[m [32mconst[39m(B[m [32mstruct[39m(B[m option_wrapper long_options[] = {[31;8H[1K {{(B[0;1m[33m"help"[39m(B[m,        no_argument,           (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'h'[39m(B[m },[32;9H[1K (B[0;1m[33m"Show help"[39m(B[m, false},[34;8H[1K {{(B[0;1m[33m"dev"[39m(B[m,         required_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'd'[39m(B[m },[35;9H[1K (B[0;1m[33m"Operate on device <ifname>"[39m(B[m, (B[0;1m[33m"<ifname>"[39m(B[m, true},[37;8H[1K {{(B[0;1m[33m"skb-mode"[39m(B[m,    no_argument,           (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'S'[39m(B[m },[38;9H[1K (B[0;1m[33m"Install XDP program in SKB (AKA generic) mode"[39m(B[m},[40;8H[1K {{(B[0;1m[33m"native-mode"[39m(B[m, no_argument,           (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'N'[39m(B[m },[2d[?12l[?25h[?25l[?12l[?25h[23d[?25l[?12l[?25h[18d[?25l[?12l[?25h[2d[?25l[?12l[?25h[?25l[?12l[?25h[2;41r[41;1H[5S[1;43r[36;10H(B[0;1m[33m"Install XDP program in native mode"[39m(B[m},[38;9H{{(B[0;1m[33m"auto-mode"[39m(B[m,   no_argument,[38;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'A'[39m(B[m },[39;10H(B[0;1m[33m"Auto-detect SKB or native mode"[39m(B[m},[2d[?25l[?12l[?25h[2;41r[41;1H[5S[1;43r[36;9H{{(B[0;1m[33m"unload"[39m(B[m,[26Grequired_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'U'[39m(B[m },[37;10H(B[0;1m[33m"Unload XDP program <id> instead of loading"[39m(B[m, (B[0;1m[33m"<id>"[39m(B[m},[39;9H{{(B[0;1m[33m"unload-all"[39m(B[m,  no_argument,[39;49H(B[0;1m[31mNULL[39m(B[m,  4  },[40;10H(B[0;1m[33m"Unload all XDP programs on device"[39m(B[m},[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[36m#include[33m <stdlib.h>[3d[36m#include[33m <string.h>[4d[36m#include[33m <errno.h>[5d[36m#include[33m <getopt.h>[7d[39m(B[m[?25l[?12l[?25h[2;40r[2;1H[5T[1;43r[2;1H(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d(B[0m[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *__doc__ = (B[0;1m[33m"XDP loader and stats program\n"[4;9H" - Allows selecting BPF --progname name to XDP-attach to --dev\n"[39m(B[m;[6d(B[0;1m[36m#include[33m <stdio.h>[12d[39m(B[m[?25l[?12l[?25h[?25l[?12l[?25h[7d[?25l[?12l[?25h[2d[?25l[?12l[?25h[?25l[?12l[?25h[?25l[41;47H(B[0;7m[ Mark Set ](B[m[1;99H(B[0;7mM   (B[m[?12l[?25h[2d[?25l[?12l[?25h(B[0;7m/* SPDX-License-Identifier: GPL-2.0 */[3dstatic const char *__doc__ = "XDP loader and stats program\n"[4d        " - Allows selecting BPF --progname name to XDP-attach to --dev\n";[6d#include <stdio.h>[7d(B[m[?25l[?12l[?25h(B[0;7m#include <stdlib.h>[8d#include <string.h>[9d#include <errno.h>[10d#include <getopt.h>[12d(B[m[?25l[?12l[?25h(B[0;7m#include <locale.h>[13d#include <unistd.h>[14d#include <time.h>[16d#include <bpf/bpf.h>[17d(B[m[?25l[41;46H(B[0;7m[ Mark Unset ](B[m[1;99H(B[0;7m    (B[m[2d(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d(B[0m[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *__doc__ = (B[0;1m[33m"XDP loader and stats program\n"[4;8H[39m(B[m[1K (B[0;1m[33m" - Allows selecting BPF --progname name to XDP-attach to --dev\n"[39m(B[m;[6d(B[0;1m[36m#include[33m <stdio.h>[7d[36m#include[33m <stdlib.h>[8d[36m#include[33m <string.h>[9d[36m#include[33m <errno.h>[10d[36m#include[33m <getopt.h>[12d[36m#include[33m <locale.h>[13d[36m#include[33m <unistd.h>[14d[36m#include[33m <time.h>[16d[36m#include[33m <bpf/bpf.h>[17d[39m(B[m[?12l[?25h[?25l[41;46H (B[0;7m[ Mark Set ](B[m[K[1;99H(B[0;7mM   (B[m[?12l[?25h[17d[?25l[?12l[?25h(B[0;7m#include <bpf/libbpf.h>[18d#include <xdp/libxdp.h>[20d#include <net/if.h>[21d#include <linux/if_link.h> /* depend on kernel-headers installed */[22d(B[m[?25l[?12l[?25h[23d(B[0;7m#include "../common/common_params.h"[24d#include "../common/common_user_bpf_xdp.h"[25d#include "common_kern_user.h"[27d(B[m[?25l[?12l[?25h(B[0;7mstatic const char *default_filename = "xdp_prog_kern.o";[28dstatic const char *default_progname = "xdp_stats1_func";[30dstatic const struct option_wrapper long_options[] = {[31d        {{"help",        no_argument,           NULL, 'h' },[32d(B[m[?25l[41d[K[?12l[?25h[32d(B[0;7m         "Show help", false},[34d        {{"dev",         required_argument,     NULL, 'd' },[35d         "Operate on device <ifname>", "<ifname>", true},[37d(B[m[?25l[?12l[?25h[2;41r[41;1H[2S[1;43r[35;1H(B[0;7m        {{"skb-mode",    no_argument,           NULL, 'S' },[36d         "Install XDP program in SKB (AKA generic) mode"},[38d        {{"native-mode", no_argument,           NULL, 'N' },[39d         "Install XDP program in native mode"},[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;7m        {{"auto-mode",   no_argument,           NULL, 'A' },[37d         "Auto-detect SKB or native mode"},[39d        {{"unload",      required_argument,     NULL, 'U' },[40;10H(B[0;1m[33m"Unload XDP program <id> instead of loading"[39m(B[m, (B[0;1m[33m"<id>"[39m(B[m},[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m         "Unload XDP program <id> instead of loading", "<id>"},[37d        {{"unload-all",  no_argument,           NULL,  4  },[38d         "Unload all XDP programs on device"},[40;9H(B[m{{(B[0;1m[33m"quiet"[39m(B[m,[26Gno_argument,[40;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'q'[39m(B[m },[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m        {{"quiet",       no_argument,           NULL, 'q' },[36d         "Quiet mode (no output)"},[38d        {{"filename",    required_argument,     NULL,  1  },[39d         "Load program from <file>", "<file>"},[40d(B[m[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[36;1H(B[0;7m        {{"progname",    required_argument,     NULL,  2  },[37d         "Load program from function <name> in the ELF file", "<name>"},[39d        {{0, 0, NULL,  0 }}[40d(B[m};[?25l[?12l[?25h7[2;41r8[41d[5S[1;43r[35;1H(B[0;7m};[37dint find_map_fd(struct bpf_object *bpf_obj, const char *mapname)[38d{[39d        struct bpf_map *map;[40;9H(B[0m[32mint[39m(B[m map_fd = -1;[?25l[?12l[?25h[35d};[37d[32mint[39m(B[m find_map_fd([32mstruct[39m(B[m bpf_object *bpf_obj, [32mconst[39m(B[m [32mchar[39m(B[m *mapname)[38d{[39;8H[1K [32mstruct[39m(B[m bpf_map *map;[35d[?25l[?12l[?25h[31;8H[1K {{(B[0;1m[33m"progname"[39m(B[m,    required_argument,     (B[0;1m[31mNULL[39m(B[m,  2  },[32;9H[1K (B[0;1m[33m"Load program from function <name> in the ELF file"[39m(B[m, (B[0;1m[33m"<name>"[39m(B[m},[34;8H[1K {{0, 0, (B[0;1m[31mNULL[39m(B[m,  0 }}[30d[?25l[?12l[?25h[25;8H[1K {{(B[0;1m[33m"quiet"[39m(B[m,       no_argument,           (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'q'[39m(B[m },[26;9H[1K (B[0;1m[33m"Quiet mode (no output)"[39m(B[m},[28;8H[1K {{(B[0;1m[33m"filename"[39m(B[m,    required_argument,     (B[0;1m[31mNULL[39m(B[m,  1  },[29;9H[1K (B[0;1m[33m"Load program from <file>"[39m(B[m, (B[0;1m[33m"<file>"[39m(B[m},[25d[?25l[?12l[?25h[20;9H[1K (B[0;1m[33m"Unload XDP program <id> instead of loading"[39m(B[m, (B[0;1m[33m"<id>"[39m(B[m},[22;8H[1K {{(B[0;1m[33m"unload-all"[39m(B[m,  no_argument,           (B[0;1m[31mNULL[39m(B[m,  4  },[23;9H[1K (B[0;1m[33m"Unload all XDP programs on device"[39m(B[m},[20d[?25l[?12l[?25h[16;8H[1K {{(B[0;1m[33m"auto-mode"[39m(B[m,   no_argument,           (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'A'[39m(B[m },[17;9H[1K (B[0;1m[33m"Auto-detect SKB or native mode"[39m(B[m},[19;8H[1K {{(B[0;1m[33m"unload"[39m(B[m,      required_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'U'[39m(B[m },[15d[?25l[?12l[?25h[10;8H[1K {{(B[0;1m[33m"skb-mode"[39m(B[m,    no_argument,           (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'S'[39m(B[m },[11;9H[1K (B[0;1m[33m"Install XDP program in SKB (AKA generic) mode"[39m(B[m},[13;8H[1K {{(B[0;1m[33m"native-mode"[39m(B[m, no_argument,           (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'N'[39m(B[m },[14;9H[1K (B[0;1m[33m"Install XDP program in native mode"[39m(B[m},[10d[?25l[?12l[?25h[5;9H[1K (B[0;1m[33m"Show help"[39m(B[m, false},[7;8H[1K {{(B[0;1m[33m"dev"[39m(B[m,         required_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'd'[39m(B[m },[8;9H[1K (B[0;1m[33m"Operate on device <ifname>"[39m(B[m, (B[0;1m[33m"<ifname>"[39m(B[m, true},[5d[?25l[?12l[?25h[2;40r[2;1H[2T[1;43r[2;1H[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *default_filename = (B[0;1m[33m"xdp_prog_kern.o"[39m(B[m;[3d[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *default_progname = (B[0;1m[33m"xdp_stats1_func"[39m(B[m;[5d[32mstatic[39m(B[m [32mconst[39m(B[m [32mstruct[39m(B[m option_wrapper long_options[] = {[6;8H[1K {{(B[0;1m[33m"help"[39m(B[m,        no_argument,           (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'h'[39m(B[m },[2d[?25l[?12l[?25h7[2;40r8[5T[1;43r[3;1H(B[0;1m[36m#include[39m(B[m (B[0;1m[33m"../common/common_params.h"[4d[36m#include[39m(B[m (B[0;1m[33m"../common/common_user_bpf_xdp.h"[5d[36m#include[39m(B[m (B[0;1m[33m"common_kern_user.h"[2d[39m(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;1m[36m#include[33m <bpf/libbpf.h>[3d[36m#include[33m <xdp/libxdp.h>[5d[36m#include[33m <net/if.h>[6d[36m#include[33m <linux/if_link.h>[39m(B[m (B[0;1m[34m/* depend on kernel-headers installed */[2d[39m(B[m[?25l[?12l[?25h7[2;41r8[5T[1;43r[2;1H(B[0;7m#include <locale.h>[3d#include <unistd.h>[4d#include <time.h>[6d#include <bpf/bpf.h>[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m#include <stdlib.h>[3d#include <string.h>[4d#include <errno.h>[5d#include <getopt.h>[2d(B[m[?25l[?12l[?25h7[2;40r8[5T[1;43r[2;1H(B[0;7m/* SPDX-License-Identifier: GPL-2.0 */[3dstatic const char *__doc__ = "XDP loader and stats program\n"[4d        " - Allows selecting BPF --progname name to XDP-attach to --dev\n";[6d#include <stdio.h>[2d(B[m[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[41;46H(B[0;7m[ Mark Unset ](B[m[1;99H(B[0;7m    (B[m[2d(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d(B[0m[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *__doc__ = (B[0;1m[33m"XDP loader and stats program\n"[4;8H[39m(B[m[1K (B[0;1m[33m" - Allows selecting BPF --progname name to XDP-attach to --dev\n"[39m(B[m;[6d(B[0;1m[36m#include[33m <stdio.h>[7d[36m#include[33m <stdlib.h>[8d[36m#include[33m <string.h>[9d[36m#include[33m <errno.h>[10d[36m#include[33m <getopt.h>[12d[36m#include[33m <locale.h>[13d[36m#include[33m <unistd.h>[14d[36m#include[33m <time.h>[16d[36m#include[33m <bpf/bpf.h>[2d[39m(B[m[?12l[?25h[?25l[41;46H (B[0;7m[ Mark Set ](B[m[K[1;99H(B[0;7mM   (B[m[?12l[?25h[2d[?25l[?12l[?25h(B[0;7m/* SPDX-License-Identifier: GPL-2.0 */[3d(B[m[?25l[?12l[?25h(B[0;7mstatic const char *__doc__ = "XDP loader and stats program\n"[4d(B[m[?25l[?12l[?25h(B[0;7m        " - Allows selecting BPF --progname name to XDP-attach to --dev\n";[5d(B[m[?25l[?12l[?25h[6d[?25l[?12l[?25h(B[0;7m#include <stdio.h>[7d(B[m[?25l[?12l[?25h(B[0;7m#include <stdlib.h>[8d(B[m[?25l[?12l[?25h(B[0;7m#include <string.h>[9d(B[m[?25l[?12l[?25h(B[0;7m#include <errno.h>[10d(B[m[?25l[?12l[?25h(B[0;7m#include <getopt.h>[11d(B[m[?25l[?12l[?25h[12d[?25l[?12l[?25h(B[0;7m#include <locale.h>[13d(B[m[?25l[?12l[?25h(B[0;7m#include <unistd.h>[14d(B[m[?25l[?12l[?25h(B[0;7m#include <time.h>[15d(B[m[?25l[?12l[?25h[16d[?25l[?12l[?25h(B[0;7m#include <bpf/bpf.h>[17d(B[m[?25l[?12l[?25h(B[0;7m#include <bpf/libbpf.h>[18d(B[m[?25l[?12l[?25h(B[0;7m#include <xdp/libxdp.h>[19d(B[m[?25l[?12l[?25h[20d[?25l[?12l[?25h(B[0;7m#include <net/if.h>[21d(B[m[?25l[41d[K[?12l[?25h[21d(B[0;7m#include <linux/if_link.h> /* depend on kernel-headers installed */[22d(B[m[?25l[?12l[?25h[23d[?25l[?12l[?25h(B[0;7m#include "../common/common_params.h"[24d(B[m[?25l[?12l[?25h(B[0;7m#include "../common/common_user_bpf_xdp.h"[25d(B[m[?25l[?12l[?25h(B[0;7m#include "common_kern_user.h"[26d(B[m[?25l[?12l[?25h[27d[?25l[?12l[?25h(B[0;7mstatic const char *default_filename = "xdp_prog_kern.o";[28d(B[m[?25l[?12l[?25h(B[0;7mstatic const char *default_progname = "xdp_stats1_func";[29d(B[m[?25l[?12l[?25h[30d[?25l[?12l[?25h(B[0;7mstatic const struct option_wrapper long_options[] = {[31d(B[m[?25l[?12l[?25h(B[0;7m        {{"help",        no_argument,           NULL, 'h' },[32d(B[m[?25l[?12l[?25h(B[0;7m         "Show help", false},[33d(B[m[?25l[?12l[?25h[34d[?25l[?12l[?25h(B[0;7m        {{"dev",         required_argument,     NULL, 'd' },[35d(B[m[?25l[?12l[?25h(B[0;7m         "Operate on device <ifname>", "<ifname>", true},[36d(B[m[?25l[?12l[?25h[37d[?25l[?12l[?25h(B[0;7m        {{"skb-mode",    no_argument,           NULL, 'S' },[38d(B[m[?25l[?12l[?25h(B[0;7m         "Install XDP program in SKB (AKA generic) mode"},[39d(B[m[?25l[?12l[?25h[40d[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        {{"native-mode", no_argument,           NULL, 'N' },[40;10H(B[0;1m[33m"Install XDP program in native mode"[39m(B[m},[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m         "Install XDP program in native mode"},[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H{{(B[0;1m[33m"auto-mode"[39m(B[m,   no_argument,[40;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'A'[39m(B[m },[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        {{"auto-mode",   no_argument,           NULL, 'A' },[40;10H(B[0;1m[33m"Auto-detect SKB or native mode"[39m(B[m},[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m         "Auto-detect SKB or native mode"},[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H{{(B[0;1m[33m"unload"[39m(B[m,[26Grequired_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'U'[39m(B[m },[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        {{"unload",      required_argument,     NULL, 'U' },[40;10H(B[0;1m[33m"Unload XDP program <id> instead of loading"[39m(B[m, (B[0;1m[33m"<id>"[39m(B[m},[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m         "Unload XDP program <id> instead of loading", "<id>"},[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H{{(B[0;1m[33m"unload-all"[39m(B[m,  no_argument,[40;49H(B[0;1m[31mNULL[39m(B[m,  4  },[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        {{"unload-all",  no_argument,           NULL,  4  },[40;10H(B[0;1m[33m"Unload all XDP programs on device"[39m(B[m},[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m         "Unload all XDP programs on device"},[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H{{(B[0;1m[33m"quiet"[39m(B[m,[26Gno_argument,[40;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'q'[39m(B[m },[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        {{"quiet",       no_argument,           NULL, 'q' },[40;10H(B[0;1m[33m"Quiet mode (no output)"[39m(B[m},[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m         "Quiet mode (no output)"},[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H{{(B[0;1m[33m"filename"[39m(B[m,    required_argument,     (B[0;1m[31mNULL[39m(B[m,  1  },[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        {{"filename",    required_argument,     NULL,  1  },[40;10H(B[0;1m[33m"Load program from <file>"[39m(B[m, (B[0;1m[33m"<file>"[39m(B[m},[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m         "Load program from <file>", "<file>"},[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H{{(B[0;1m[33m"progname"[39m(B[m,    required_argument,     (B[0;1m[31mNULL[39m(B[m,  2  },[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        {{"progname",    required_argument,     NULL,  2  },[40;10H(B[0;1m[33m"Load program from function <name> in the ELF file"[39m(B[m, (B[0;1m[33m"<name>"[39m(B[m},[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m         "Load program from function <name> in the ELF file", "<name>"},[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H{{0, 0, (B[0;1m[31mNULL[39m(B[m,  0 }}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        {{0, 0, NULL,  0 }}[40d(B[m};[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m};[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;1H[32mint[39m(B[m find_map_fd([32mstruct[39m(B[m bpf_object *bpf_obj, [32mconst[39m(B[m [32mchar[39m(B[m *mapname)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7mint find_map_fd(struct bpf_object *bpf_obj, const char *mapname)[40d(B[m{[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m{[40;9H(B[0m[32mstruct[39m(B[m bpf_map *map;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        struct bpf_map *map;[40;9H(B[0m[32mint[39m(B[m map_fd = -1;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        int map_fd = -1;[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[34m/* Lesson#3: bpf_object to bpf_map */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* Lesson#3: bpf_object to bpf_map */[40;9H(B[mmap = bpf_object__find_map_by_name(bpf_obj, mapname);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        map = bpf_object__find_map_by_name(bpf_obj, mapname);[40;9H(B[0;1m[33mif[39m(B[m (!map) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (!map) {[40;17H(B[mfprintf(stderr, (B[0;1m[33m"ERR: cannot find map by name: %s\n"[39m(B[m, mapname);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                fprintf(stderr, "ERR: cannot find map by name: %s\n", mapname);[40;17H(B[0m[35mgoto[39m(B[m out;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                goto out;[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9Hmap_fd = bpf_map__fd(map);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        map_fd = bpf_map__fd(map);[40d(B[0;1m[35m out(B[0m:(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m out:[40;9H(B[0m[35mreturn[39m(B[m map_fd;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        return map_fd;[40d(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m}[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;1H(B[0;1m[36m#define[39m(B[m (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m 1000000000 (B[0;1m[34m/* 10^9 */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m#define NANOSEC_PER_SEC 1000000000 /* 10^9 */[40d(B[0m[32mstatic[39m(B[m __u64 gettime([32mvoid[39m(B[m)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7mstatic __u64 gettime(void)[40d(B[m{[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m{[40;9H(B[0m[32mstruct[39m(B[m timespec t;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        struct timespec t;[40;9H(B[0m[32mint[39m(B[m res;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        int res;[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9Hres = clock_gettime((B[0;1m[31mCLOCK_MONOTONIC[39m(B[m, &t);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        res = clock_gettime(CLOCK_MONOTONIC, &t);[40;9H(B[0;1m[33mif[39m(B[m (res < 0) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (res < 0) {[40;17H(B[mfprintf(stderr, (B[0;1m[33m"Error with gettimeofday! (%i)\n"[39m(B[m, res);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                fprintf(stderr, "Error with gettimeofday! (%i)\n", res);[40;17H(B[mexit((B[0;1m[31mEXIT_FAIL[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                exit(EXIT_FAIL);[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[0m[35mreturn[39m(B[m (__u64) t.tv_sec * (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m + t.tv_nsec;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        return (__u64) t.tv_sec * NANOSEC_PER_SEC + t.tv_nsec;[40d(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m}[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;1H[32mstruct[39m(B[m record {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7mstruct record {[40;9H(B[m__u64 timestamp;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        __u64 timestamp;[40;9H(B[0m[32mstruct[39m(B[m datarec total; (B[0;1m[34m/* defined in common_kern_user.h */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        struct datarec total; /* defined in common_kern_user.h */[40d(B[m};[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m};[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;1H[32mstruct[39m(B[m stats_record {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7mstruct stats_record {[40;9H(B[0m[32mstruct[39m(B[m record stats[1]; (B[0;1m[34m/* Assignment#2: Hint */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        struct record stats[1]; /* Assignment#2: Hint */[40d(B[m};[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m};[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;1H[32mstatic[39m(B[m [32mdouble[39m(B[m calc_period([32mstruct[39m(B[m record *r, [32mstruct[39m(B[m record *p)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7mstatic double calc_period(struct record *r, struct record *p)[40d(B[m{[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m{[40;9H(B[0m[32mdouble[39m(B[m period_ = 0;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        double period_ = 0;[40;9H(B[m__u64 period = 0;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        __u64 period = 0;[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9Hperiod = r->timestamp - p->timestamp;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        period = r->timestamp - p->timestamp;[40;9H(B[0;1m[33mif[39m(B[m (period > 0)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (period > 0)[40;17H(B[mperiod_ = (([32mdouble[39m(B[m) period / (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                period_ = ((double) period / NANOSEC_PER_SEC);[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H[35mreturn[39m(B[m period_;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        return period_;[40d(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m}[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;1H[32mstatic[39m(B[m [32mvoid[39m(B[m stats_print([32mstruct[39m(B[m stats_record *stats_rec,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7mstatic void stats_print(struct stats_record *stats_rec,[40;25H(B[0m[32mstruct[39m(B[m stats_record *stats_prev)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        struct stats_record *stats_prev)[40d(B[m{[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m{[40;9H(B[0m[32mstruct[39m(B[m record *rec, *prev;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        struct record *rec, *prev;[40;9H(B[0m[32mdouble[39m(B[m period;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        double period;[40;9H(B[m__u64 packets;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        __u64 packets;[40;9H(B[0m[32mdouble[39m(B[m pps; (B[0;1m[34m/* packets per sec */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        double pps; /* packets per sec */[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[34m/* Assignment#2: Print other XDP actions stats  */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* Assignment#2: Print other XDP actions stats  */[40;9H(B[m{[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        {[40;17H(B[0m[32mchar[39m(B[m *fmt = (B[0;1m[33m"%-12s %'11lld pkts (%'10.0f pps)"[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                char *fmt = "%-12s %'11lld pkts (%'10.0f pps)"[40;25H(B[0;1m[34m//" %'11lld Kbytes (%'6.0f Mbits/s)"[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        //" %'11lld Kbytes (%'6.0f Mbits/s)"[40;25H(B[0;1m[33m" period:%f\n"[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        " period:%f\n";[40;17H(B[0m[32mconst[39m(B[m [32mchar[39m(B[m *action = action2str((B[0;1m[31mXDP_PASS[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                const char *action = action2str(XDP_PASS);[40;17H(B[mrec  = &stats_rec->stats[0];[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                rec  = &stats_rec->stats[0];[40;17H(B[mprev = &stats_prev->stats[0];[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                prev = &stats_prev->stats[0];[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;17Hperiod = calc_period(rec, prev);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                period = calc_period(rec, prev);[40;17H(B[0;1m[33mif[39m(B[m (period == 0)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                if (period == 0)[40;24H(B[0m[35mreturn[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                       return;[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;17Hpackets = rec->total.rx_packets - prev->total.rx_packets;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                packets = rec->total.rx_packets - prev->total.rx_packets;[40;17H(B[mpps     = packets / period;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                pps     = packets / period;[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;17Hprintf(fmt, action, rec->total.rx_packets, pps, period);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                printf(fmt, action, rec->total.rx_packets, pps, period);[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m}[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;1H(B[0;1m[34m/* BPF_MAP_TYPE_ARRAY */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m/* BPF_MAP_TYPE_ARRAY */[40d(B[0m[32mvoid[39m(B[m map_get_value_array([32mint[39m(B[m fd, __u32 key, [32mstruct[39m(B[m datarec *value)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7mvoid map_get_value_array(int fd, __u32 key, struct datarec *value)[40d(B[m{[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m{[40;9H(B[0;1m[33mif[39m(B[m ((bpf_map_lookup_elem(fd, &key, value)) != 0) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if ((bpf_map_lookup_elem(fd, &key, value)) != 0) {[40;17H(B[mfprintf(stderr,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                fprintf(stderr,[40;25H(B[0;1m[33m"ERR: bpf_map_lookup_elem failed key:0x%X\n"[39m(B[m, key);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        "ERR: bpf_map_lookup_elem failed key:0x%X\n", key);[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m}[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;1H(B[0;1m[34m/* BPF_MAP_TYPE_PERCPU_ARRAY */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m/* BPF_MAP_TYPE_PERCPU_ARRAY */[40d(B[0m[32mvoid[39m(B[m map_get_value_percpu_array([32mint[39m(B[m fd, __u32 key, [32mstruct[39m(B[m datarec *value)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7mvoid map_get_value_percpu_array(int fd, __u32 key, struct datarec *value)[40d(B[m{[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m{[40;9H(B[0;1m[34m/* For percpu maps, userspace gets a value per possible CPU */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* For percpu maps, userspace gets a value per possible CPU */[40;9H(B[0;1m[34m// unsigned int nr_cpus = libbpf_num_possible_cpus();[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        // unsigned int nr_cpus = libbpf_num_possible_cpus();[40;9H(B[0;1m[34m// struct datarec values[nr_cpus];[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        // struct datarec values[nr_cpus];[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9Hfprintf(stderr, (B[0;1m[33m"ERR: %s() not impl. see assignment#3"[39m(B[m, __func__);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        fprintf(stderr, "ERR: %s() not impl. see assignment#3", __func__);[40d(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m}[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;1H[32mstatic[39m(B[m [32mbool[39m(B[m map_collect([32mint[39m(B[m fd, __u32 map_type, __u32 key, [32mstruct[39m(B[m record *rec)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7mstatic bool map_collect(int fd, __u32 map_type, __u32 key, struct record *rec)[40d(B[m{[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m{[40;9H(B[0m[32mstruct[39m(B[m datarec value;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        struct datarec value;[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[34m/* Get time as close as possible to reading map contents */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* Get time as close as possible to reading map contents */[40;9H(B[mrec->timestamp = gettime();[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        rec->timestamp = gettime();[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[33mswitch[39m(B[m (map_type) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        switch (map_type) {[40;9H(B[0;1m[33mcase[39m(B[m (B[0;1m[31mBPF_MAP_TYPE_ARRAY(B[0m:(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        case BPF_MAP_TYPE_ARRAY:[40;17H(B[mmap_get_value_array(fd, key, &value);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                map_get_value_array(fd, key, &value);[40;17H(B[0m[35mbreak[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                break;[40;9H(B[0;1m[33mcase[39m(B[m (B[0;1m[31mBPF_MAP_TYPE_PERCPU_ARRAY(B[0m:(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        case BPF_MAP_TYPE_PERCPU_ARRAY:[40;17H(B[0;1m[34m/* fall-through */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                /* fall-through */[40;8H(B[0;1m[35m[1K [33mdefault(B[0m:(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        default:[40d(B[mfprintf(stderr, (B[0;1m[33m"ERR: Unknown map_type(%u) cannot handle\n"[39m(B[m,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                fprintf(stderr, "ERR: Unknown map_type(%u) cannot handle\n",[40;25H(B[mmap_type);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        map_type);[40;17H(B[0m[35mreturn[39m(B[m false;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                return false;[40;17H(B[0m[35mbreak[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                break;[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[34m/* Assignment#1: Add byte counters */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* Assignment#1: Add byte counters */[40;9H(B[mrec->total.rx_packets = value.rx_packets;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        rec->total.rx_packets = value.rx_packets;[40;9H(B[0m[35mreturn[39m(B[m true;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        return true;[40d(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m}[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;1H[32mstatic[39m(B[m [32mvoid[39m(B[m stats_collect([32mint[39m(B[m map_fd, __u32 map_type,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7mstatic void stats_collect(int map_fd, __u32 map_type,[40;27H(B[0m[32mstruct[39m(B[m stats_record *stats_rec)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                          struct stats_record *stats_rec)[40d(B[m{[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m{[40;9H(B[0;1m[34m/* Assignment#2: Collect other XDP actions stats  */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* Assignment#2: Collect other XDP actions stats  */[40;9H(B[m__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        __u32 key = XDP_PASS;[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9Hmap_collect(map_fd, map_type, key, &stats_rec->stats[0]);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        map_collect(map_fd, map_type, key, &stats_rec->stats[0]);[40d(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m}[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;1H[32mstatic[39m(B[m [32mvoid[39m(B[m stats_poll([32mint[39m(B[m map_fd, __u32 map_type, [32mint[39m(B[m interval)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7mstatic void stats_poll(int map_fd, __u32 map_type, int interval)[40d(B[m{[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m{[40;9H(B[0m[32mstruct[39m(B[m stats_record prev, record = { 0 };[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        struct stats_record prev, record = { 0 };[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[34m/* Trick to pretty printf with thousands separators use %' */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* Trick to pretty printf with thousands separators use %' */[40;9H(B[msetlocale((B[0;1m[31mLC_NUMERIC[39m(B[m, (B[0;1m[33m"en_US"[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        setlocale(LC_NUMERIC, "en_US");[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[34m/* Print stats "header" */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* Print stats "header" */[40;9H(B[0;1m[33mif[39m(B[m (verbose) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (verbose) {[40;17H(B[mprintf((B[0;1m[33m"\n"[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                printf("\n");[40;17H(B[mprintf((B[0;1m[33m"%-12s\n"[39m(B[m, (B[0;1m[33m"XDP-action"[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                printf("%-12s\n", "XDP-action");[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[34m/* Get initial reading quickly */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* Get initial reading quickly */[40;9H(B[mstats_collect(map_fd, map_type, &record);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        stats_collect(map_fd, map_type, &record);[40;9H(B[musleep(1000000/4);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        usleep(1000000/4);[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[33mwhile[39m(B[m (1) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        while (1) {[40;17H(B[mprev = record; (B[0;1m[34m/* struct copy */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                prev = record; /* struct copy */[40;17H(B[mstats_collect(map_fd, map_type, &record);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                stats_collect(map_fd, map_type, &record);[40;17H(B[mstats_print(&record, &prev);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                stats_print(&record, &prev);[40;17H(B[msleep(interval);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                sleep(interval);[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m}[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;1H(B[0;1m[34m/* Lesson#4: It is userspace responsibility to known what map it is reading and[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m/* Lesson#4: It is userspace responsibility to known what map it is reading and[40d(B[0;1m[34m * know the value size. Here get bpf_map_info and check if it match our expected[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m * know the value size. Here get bpf_map_info and check if it match our expected[40d(B[0;1m[34m * values.[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m * values.[40d(B[0;1m[34m */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m */[40d(B[0m[32mstatic[39m(B[m [32mint[39m(B[m __check_map_fd_info([32mint[39m(B[m map_fd, [32mstruct[39m(B[m bpf_map_info *info,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7mstatic int __check_map_fd_info(int map_fd, struct bpf_map_info *info,[40;32H(B[0m[32mstruct[39m(B[m bpf_map_info *exp)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                               struct bpf_map_info *exp)[40d(B[m{[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m{[40;9H(B[m__u32 info_len = [32msizeof[39m(B[m(*info);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        __u32 info_len = sizeof(*info);[40;9H(B[0m[32mint[39m(B[m err;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        int err;[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[33mif[39m(B[m (map_fd < 0)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (map_fd < 0)[40;17H(B[0m[35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                return EXIT_FAIL;[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[34m/* BPF-info via bpf-syscall */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* BPF-info via bpf-syscall */[40;9H(B[merr = bpf_obj_get_info_by_fd(map_fd, info, &info_len);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        err = bpf_obj_get_info_by_fd(map_fd, info, &info_len);[40;9H(B[0;1m[33mif[39m(B[m (err) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (err) {[40d(B[mfprintf(stderr, (B[0;1m[33m"ERR: %s() can't get info - %s\n"[39m(B[m,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                fprintf(stderr, "ERR: %s() can't get info - %s\n",[40;25H(B[m__func__,  strerror(errno));[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        __func__,  strerror(errno));[40;17H(B[0m[35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL_BPF[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                return EXIT_FAIL_BPF;[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[33mif[39m(B[m (exp->key_size && exp->key_size != info->key_size) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (exp->key_size && exp->key_size != info->key_size) {[40;17H(B[mfprintf(stderr, (B[0;1m[33m"ERR: %s() "[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                fprintf(stderr, "ERR: %s() "[40;25H(B[0;1m[33m"Map key size(%d) mismatch expected size(%d)\n"[39m(B[m,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        "Map key size(%d) mismatch expected size(%d)\n",[40;25H(B[m__func__, info->key_size, exp->key_size);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        __func__, info->key_size, exp->key_size);[40;17H(B[0m[35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                return EXIT_FAIL;[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[0;1m[33mif[39m(B[m (exp->value_size && exp->value_size != info->value_size) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (exp->value_size && exp->value_size != info->value_size) {[40;17H(B[mfprintf(stderr, (B[0;1m[33m"ERR: %s() "[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                fprintf(stderr, "ERR: %s() "[40;25H(B[0;1m[33m"Map value size(%d) mismatch expected size(%d)\n"[39m(B[m,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        "Map value size(%d) mismatch expected size(%d)\n",[40;25H(B[m__func__, info->value_size, exp->value_size);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        __func__, info->value_size, exp->value_size);[40;17H(B[0m[35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                return EXIT_FAIL;[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[0;1m[33mif[39m(B[m (exp->max_entries && exp->max_entries != info->max_entries) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (exp->max_entries && exp->max_entries != info->max_entries) {[40;17H(B[mfprintf(stderr, (B[0;1m[33m"ERR: %s() "[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                fprintf(stderr, "ERR: %s() "[40;25H(B[0;1m[33m"Map max_entries(%d) mismatch expected size(%d)\n"[39m(B[m,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        "Map max_entries(%d) mismatch expected size(%d)\n",[40;25H(B[m__func__, info->max_entries, exp->max_entries);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        __func__, info->max_entries, exp->max_entries);[40;17H(B[0m[35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                return EXIT_FAIL;[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[0;1m[33mif[39m(B[m (exp->type && exp->type  != info->type) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (exp->type && exp->type  != info->type) {[40;17H(B[mfprintf(stderr, (B[0;1m[33m"ERR: %s() "[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                fprintf(stderr, "ERR: %s() "[40;25H(B[0;1m[33m"Map type(%d) mismatch expected type(%d)\n"[39m(B[m,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        "Map type(%d) mismatch expected type(%d)\n",[40;25H(B[m__func__, info->type, exp->type);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        __func__, info->type, exp->type);[40;17H(B[0m[35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                return EXIT_FAIL;[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H[35mreturn[39m(B[m 0;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        return 0;[40d(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m}[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;1H[32mint[39m(B[m main([32mint[39m(B[m argc, [32mchar[39m(B[m **argv)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7mint main(int argc, char **argv)[40d(B[m{[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m{[40;9H(B[0m[32mstruct[39m(B[m bpf_map_info map_expect = { 0 };[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        struct bpf_map_info map_expect = { 0 };[40;9H(B[0m[32mstruct[39m(B[m bpf_map_info info = { 0 };[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        struct bpf_map_info info = { 0 };[40;9H(B[0m[32mstruct[39m(B[m xdp_program *program;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        struct xdp_program *program;[40;9H(B[0m[32mint[39m(B[m stats_map_fd;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        int stats_map_fd;[40;9H(B[0m[32mint[39m(B[m interval = 2;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        int interval = 2;[40;9H(B[0m[32mchar[39m(B[m errmsg[1024];[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        char errmsg[1024];[40;9H(B[0m[32mint[39m(B[m err;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        int err;[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H[32mstruct[39m(B[m config cfg = {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        struct config cfg = {[40;17H(B[m.ifindex   = -1,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                .ifindex   = -1,[40;17H(B[m.do_unload = false,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                .do_unload = false,[40;9H(B[m};[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        };[40d(B[0;1m[34m/* Set default BPF-ELF object file and BPF program name */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* Set default BPF-ELF object file and BPF program name */[40;9H(B[mstrncpy(cfg.filename, default_filename, [32msizeof[39m(B[m(cfg.filename));[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        strncpy(cfg.filename, default_filename, sizeof(cfg.filename));[40;9H(B[mstrncpy(cfg.progname,  default_progname,  [32msizeof[39m(B[m(cfg.progname));[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        strncpy(cfg.progname,  default_progname,  sizeof(cfg.progname));[40;9H(B[0;1m[34m/* Cmdline options can change progname */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* Cmdline options can change progname */[40;9H(B[mparse_cmdline_args(argc, argv, long_options, &cfg, __doc__);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        parse_cmdline_args(argc, argv, long_options, &cfg, __doc__);[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[34m/* Required option */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* Required option */[40;9H(B[0;1m[33mif[39m(B[m (cfg.ifindex == -1) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (cfg.ifindex == -1) {[40;17H(B[mfprintf(stderr, (B[0;1m[33m"ERR: required option --dev missing\n"[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                fprintf(stderr, "ERR: required option --dev missing\n");[40;17H(B[musage(argv[0], __doc__, long_options, (argc == 1));[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                usage(argv[0], __doc__, long_options, (argc == 1));[40;17H(B[0m[35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL_OPTION[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                return EXIT_FAIL_OPTION;[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[34m/* Unload a program by prog_id, or[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* Unload a program by prog_id, or[40;9H(B[0;1m[34m[1K * unload all programs on net device[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m         * unload all programs on net device[40;9H(B[0;1m[34m[1K */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m         */[40;9H(B[0;1m[33mif[39m(B[m (cfg.do_unload || cfg.unload_all) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (cfg.do_unload || cfg.unload_all) {[40;17H(B[merr = do_unload(&cfg);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                err = do_unload(&cfg);[40;17H(B[0;1m[33mif[39m(B[m (err) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                if (err) {[40d(B[mlibxdp_strerror(err, errmsg, [32msizeof[39m(B[m(errmsg));[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        libxdp_strerror(err, errmsg, sizeof(errmsg));[40;25H(B[mfprintf(stderr, (B[0;1m[33m"Couldn't unload XDP program %d: %s\n"[39m(B[m,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        fprintf(stderr, "Couldn't unload XDP program %d: %s\n",[40;33H(B[mcfg.prog_id, errmsg);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                                cfg.prog_id, errmsg);[40;25H(B[0m[35mreturn[39m(B[m err;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                        return err;[40;17H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;17Hprintf((B[0;1m[33m"Success: Unloading XDP prog name: %s\n"[39m(B[m, cfg.progname);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                printf("Success: Unloading XDP prog name: %s\n", cfg.progname);[40;17H(B[0m[35mreturn[39m(B[m (B[0;1m[31mEXIT_OK[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                return EXIT_OK;[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9Hprogram = load_bpf_and_xdp_attach(&cfg);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        program = load_bpf_and_xdp_attach(&cfg);[40;9H(B[0;1m[33mif[39m(B[m (!program)[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (!program)[40;17H(B[0m[35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL_BPF[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                return EXIT_FAIL_BPF;[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[33mif[39m(B[m (verbose) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (verbose) {[40;17H(B[mprintf((B[0;1m[33m"Success: Loaded BPF-object(%s) and used section(%s)\n"[39m(B[m,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                printf("Success: Loaded BPF-object(%s) and used section(%s)\n",[40;24H(B[mcfg.filename, cfg.progname);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                       cfg.filename, cfg.progname);[40;17H(B[mprintf((B[0;1m[33m" - XDP prog id:%d attached on device:%s(ifindex:%d)\n"[39m(B[m,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                printf(" - XDP prog id:%d attached on device:%s(ifindex:%d)\n",[40;24H(B[mxdp_program__id(program), cfg.ifname, cfg.ifindex);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                       xdp_program__id(program), cfg.ifname, cfg.ifindex);[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[34m/* Lesson#3: Locate map file descriptor */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* Lesson#3: Locate map file descriptor */[40;9H(B[mstats_map_fd = find_map_fd(xdp_program__bpf_obj(program), (B[0;1m[33m"xdp_stats_map"[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        stats_map_fd = find_map_fd(xdp_program__bpf_obj(program), "xdp_stats_map");[40;9H(B[0;1m[33mif[39m(B[m (stats_map_fd < 0) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (stats_map_fd < 0) {[40;17H(B[0;1m[34m/* xdp_link_detach(cfg.ifindex, cfg.xdp_flags, 0); */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                /* xdp_link_detach(cfg.ifindex, cfg.xdp_flags, 0); */[40;17H(B[0m[35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL_BPF[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                return EXIT_FAIL_BPF;[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9H(B[0;1m[34m/* Lesson#4: check map info, e.g. datarec is expected size */[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        /* Lesson#4: check map info, e.g. datarec is expected size */[40;9H(B[mmap_expect.key_size    = [32msizeof[39m(B[m(__u32);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        map_expect.key_size    = sizeof(__u32);[40;9H(B[mmap_expect.value_size  = [32msizeof[39m(B[m([32mstruct[39m(B[m datarec);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        map_expect.value_size  = sizeof(struct datarec);[40;9H(B[mmap_expect.max_entries = (B[0;1m[31mXDP_ACTION_MAX[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        map_expect.max_entries = XDP_ACTION_MAX;[40;9H(B[merr = __check_map_fd_info(stats_map_fd, &info, &map_expect);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        err = __check_map_fd_info(stats_map_fd, &info, &map_expect);[40;9H(B[0;1m[33mif[39m(B[m (err) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (err) {[40d(B[mfprintf(stderr, (B[0;1m[33m"ERR: map via FD not compatible\n"[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                fprintf(stderr, "ERR: map via FD not compatible\n");[40;17H(B[0m[35mreturn[39m(B[m err;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                return err;[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[0;1m[33mif[39m(B[m (verbose) {[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        if (verbose) {[40;17H(B[mprintf((B[0;1m[33m"\nCollecting stats from BPF map\n"[39m(B[m);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                printf("\nCollecting stats from BPF map\n");[40;17H(B[mprintf((B[0;1m[33m" - BPF map (bpf_map_type:%d) id:%d name:%s"[39m(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                printf(" - BPF map (bpf_map_type:%d) id:%d name:%s"[40;24H(B[0;1m[33m" key_size:%d value_size:%d max_entries:%d\n"[39m(B[m,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                       " key_size:%d value_size:%d max_entries:%d\n",[40;24H(B[minfo.type, info.id, info.name,[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                       info.type, info.id, info.name,[40;24H(B[minfo.key_size, info.value_size, info.max_entries[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                       info.key_size, info.value_size, info.max_entries[40;24H(B[m);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m                       );[40;9H(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        }[40d(B[m[?25l[?12l[?25h7[2;41r8[41d
[1;43r[40;9Hstats_poll(stats_map_fd, info.type, interval);[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        stats_poll(stats_map_fd, info.type, interval);[40;9H(B[0m[35mreturn[39m(B[m (B[0;1m[31mEXIT_OK[39m(B[m;[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m        return EXIT_OK;[40d(B[m}[?25l[?12l[?25h7[2;41r8[41d
[1;43r[39;1H(B[0;7m}[40d(B[m[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[41;46H(B[0;7m[ Mark Unset ](B[m[1;99H(B[0;7m    (B[m[2;8H[1K (B[0;1m[33mif[39m(B[m (!program)[3;16H[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL_BPF[39m(B[m;[5;8H[1K (B[0;1m[33mif[39m(B[m (verbose) {[6;16H[1K printf((B[0;1m[33m"Success: Loaded BPF-object(%s) and used section(%s)\n"[39m(B[m,[7;23H[1K cfg.filename, cfg.progname);[8;16H[1K printf((B[0;1m[33m" - XDP prog id:%d attached on device:%s(ifindex:%d)\n"[39m(B[m,[9;23H[1K xdp_program__id(program), cfg.ifname, cfg.ifindex);[10;8H[1K }[12d[1K (B[0;1m[34m/* Lesson#3: Locate map file descriptor */[13;8H[39m(B[m[1K stats_map_fd = find_map_fd(xdp_program__bpf_obj(program), (B[0;1m[33m"xdp_stats_map"[39m(B[m);[14;8H[1K (B[0;1m[33mif[39m(B[m (stats_map_fd < 0) {[15;16H[1K (B[0;1m[34m/* xdp_link_detach(cfg.ifindex, cfg.xdp_flags, 0); */[16;16H[39m(B[m[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL_BPF[39m(B[m;[17;8H[1K }[19d[1K (B[0;1m[34m/* Lesson#4: check map info, e.g. datarec is expected size */[20;8H[39m(B[m[1K map_expect.key_size    = [32msizeof[39m(B[m(__u32);[21;8H[1K map_expect.value_size  = [32msizeof[39m(B[m([32mstruct[39m(B[m datarec);[22;8H[1K map_expect.max_entries = (B[0;1m[31mXDP_ACTION_MAX[39m(B[m;[23;8H[1K err = __check_map_fd_info(stats_map_fd, &info, &map_expect);[24;8H[1K (B[0;1m[33mif[39m(B[m (err) {[25;16H[1K fprintf(stderr, (B[0;1m[33m"ERR: map via FD not compatible\n"[39m(B[m);[26;16H[1K [35mreturn[39m(B[m err;[27;8H[1K }[28d[1K (B[0;1m[33mif[39m(B[m (verbose) {[29;16H[1K printf((B[0;1m[33m"\nCollecting stats from BPF map\n"[39m(B[m);[30;16H[1K printf((B[0;1m[33m" - BPF map (bpf_map_type:%d) id:%d name:%s"[31;23H[39m(B[m[1K (B[0;1m[33m" key_size:%d value_size:%d max_entries:%d\n"[39m(B[m,[32;23H[1K info.type, info.id, info.name,[33;23H[1K info.key_size, info.value_size, info.max_entries[34;23H[1K );[35;8H[1K }[37d[1K stats_poll(stats_map_fd, info.type, interval);[38;8H[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_OK[39m(B[m;[39d}[40d[?12l[?25h[?25l[?12l[?25h[35d[?25l[?12l[?25h[30d[?25l[?12l[?25h[25d[?25l[41d[K[?12l[?25h[26d[?25l[41d[?12l[?25h[27d[?25l[41d[?12l[?25h[28d[?25l[?12l[?25h[2;41r[41;1H
[1;43r[27;1H[?25l[41d[?12l[?25h[28d[?25l[?12l[?25h[29d[?25l[?12l[?25h[30d[?25l[?12l[?25h[31d[?25l[?12l[?25h[32d[?25l[?12l[?25h[33d[?25l[?12l[?25h[34d[?25l[?12l[?25h[35d[?25l[?12l[?25h[36d[?25l[?12l[?25h[37d[?25l[?12l[?25h[38d[?25l[?12l[?25h[39d[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[41;47H(B[0;7m[ Mark Set ](B[m[1;99H(B[0;7mM   (B[m[?12l[?25h[39d[?25l[?12l[?25h[A(B[0;7m}(B[m[?25l[?12l[?25h[A(B[0;7m        return EXIT_OK;(B[m[?25l[?12l[?25h[A(B[0;7m        stats_poll(stats_map_fd, info.type, interval);(B[m[?25l[?12l[?25h[A[?25l[?12l[?25h[A(B[0;7m        }(B[m[?25l[?12l[?25h[A(B[0;7m                       );(B[m[?25l[?12l[?25h[A(B[0;7m                       info.key_size, info.value_size, info.max_entries(B[m[?25l[?12l[?25h[A(B[0;7m                       info.type, info.id, info.name,(B[m[?25l[?12l[?25h[A(B[0;7m                       " key_size:%d value_size:%d max_entries:%d\n",(B[m[?25l[?12l[?25h[A(B[0;7m                printf(" - BPF map (bpf_map_type:%d) id:%d name:%s"(B[m[?25l[?12l[?25h[A(B[0;7m                printf("\nCollecting stats from BPF map\n");(B[m[?25l[?12l[?25h[A(B[0;7m        if (verbose) {(B[m[?25l[?12l[?25h[A(B[0;7m        }(B[m[?25l[?12l[?25h[A(B[0;7m                return err;(B[m[?25l[?12l[?25h[A(B[0;7m                fprintf(stderr, "ERR: map via FD not compatible\n");(B[m[?25l[?12l[?25h[A(B[0;7m        if (err) {(B[m[?25l[?12l[?25h[A(B[0;7m        err = __check_map_fd_info(stats_map_fd, &info, &map_expect);(B[m[?25l[?12l[?25h[A(B[0;7m        map_expect.max_entries = XDP_ACTION_MAX;(B[m[?25l[?12l[?25h[A(B[0;7m        map_expect.value_size  = sizeof(struct datarec);(B[m[?25l[41d[K[?12l[?25h[19d(B[0;7m        map_expect.key_size    = sizeof(__u32);(B[m[?25l[?12l[?25h[A(B[0;7m        /* Lesson#4: check map info, e.g. datarec is expected size */(B[m[?25l[?12l[?25h[A[?25l[?12l[?25h[A(B[0;7m        }(B[m[?25l[?12l[?25h[A(B[0;7m                return EXIT_FAIL_BPF;(B[m[?25l[?12l[?25h[A(B[0;7m                /* xdp_link_detach(cfg.ifindex, cfg.xdp_flags, 0); */(B[m[?25l[?12l[?25h[A(B[0;7m        if (stats_map_fd < 0) {(B[m[?25l[?12l[?25h[A(B[0;7m        stats_map_fd = find_map_fd(xdp_program__bpf_obj(program), "xdp_stats_map");(B[m[?25l[?12l[?25h[A(B[0;7m        /* Lesson#3: Locate map file descriptor */(B[m[?25l[?12l[?25h[A[?25l[?12l[?25h[A(B[0;7m        }(B[m[?25l[?12l[?25h[A(B[0;7m                       xdp_program__id(program), cfg.ifname, cfg.ifindex);(B[m[?25l[?12l[?25h[A(B[0;7m                printf(" - XDP prog id:%d attached on device:%s(ifindex:%d)\n",(B[m[?25l[?12l[?25h[A(B[0;7m                       cfg.filename, cfg.progname);(B[m[?25l[?12l[?25h[A(B[0;7m                printf("Success: Loaded BPF-object(%s) and used section(%s)\n",(B[m[?25l[?12l[?25h[A(B[0;7m        if (verbose) {(B[m[?25l[?12l[?25h[A[?25l[?12l[?25h[A(B[0;7m                return EXIT_FAIL_BPF;(B[m[?25l[?12l[?25h7[2;41r8M[1;43r[2;1H(B[0;7m        if (!program)(B[m[?25l[?12l[?25h7[2;41r8M[1;43r[2;1H(B[0;7m        program = load_bpf_and_xdp_attach(&cfg);(B[m[?25l[8G[1K (B[0;1m[34m/* Required option */[39m(B[m[K[3;8H[1K (B[0;1m[33mif[39m(B[m (cfg.ifindex == -1) {[4;16H[1K fprintf(stderr, (B[0;1m[33m"ERR: required option --dev missing\n"[39m(B[m);[5;17Husage(argv[0], __doc__, long_options, (argc == 1));[6;16H[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL_OPTION[39m(B[m;[7;8H[1K }[K[8d[K[9;8H[1K (B[0;1m[34m/* Unload a program by prog_id, or[39m(B[m[K[10;9H(B[0;1m[34m[1K * unload all programs on net device[39m(B[m[K[11;9H(B[0;1m[34m[1K */[12;9H[33mif[39m(B[m (cfg.do_unload || cfg.unload_all) {[13;16H[1K err = do_unload(&cfg);[K[14;16H[1K (B[0;1m[33mif[39m(B[m (err) {[K[15;24H[1K libxdp_strerror(err, errmsg, [32msizeof[39m(B[m(errmsg));[16;24H[1K fprintf(stderr, (B[0;1m[33m"Couldn't unload XDP program %d: %s\n"[39m(B[m,[17;32H[1K cfg.prog_id, errmsg);[18;24H[1K [35mreturn[39m(B[m err;[19;17H}[20d[K[21;9H(B[0;7m        printf("Success: Unloading XDP prog name: %s\n", cfg.progname);[22;9H        return EXIT_OK;(B[m[K[23;9H(B[0;7m}(B[m[K[24d[K[25;9H(B[0;7mprogram = load_bpf_and_xdp_attach(&cfg);[26;9Hif (!program)(B[m[K[27;24H(B[0;7mEXIT_FAIL_BPF;[28d(B[m[K[30;25H(B[0;7mSuccess: Loaded BPF-object(%s) and used section(%s)\n",[31;17H       cfg.filename, cfg.progname);(B[m[K[32;17H(B[0;7mprintf(" - XDP prog id:%d attached on device:%s(ifindex:%d)\n",[33;24Hxdp_program__id(program), cfg.ifname, cfg.ifindex);[34;9H}(B[m[K[35d[K[36;9H(B[0;7m/* Lesson#3: Locate map file descriptor */[37d        stats_map_fd = find_map_fd(xdp_program__bpf_obj(program), "xdp_stats_map");[38;9Hif (stats_map_fd < 0) {(B[m[K[39;9H(B[0;7m        /* xdp_link_detach(cfg.ifindex, cfg.xdp_flags, 0); */[40d                return EXIT_FAIL_BPF;[21d(B[m[?12l[?25h[?25l[?12l[?25h[9d(B[0;7m        /* Unload a program by prog_id, or[10d         * unload all programs on net device[11d         */[12d        if (cfg.do_unload || cfg.unload_all) {[13d                err = do_unload(&cfg);[14d                if (err) {[15d                        libxdp_strerror(err, errmsg, sizeof(errmsg));[16d                        fprintf(stderr, "Couldn't unload XDP program %d: %s\n",[17d                                cfg.prog_id, errmsg);[18d                        return err;[19d                }[9d(B[m[?25l[?12l[?25h[2d(B[0;7m        /* Required option */[3d        if (cfg.ifindex == -1) {[4d                fprintf(stderr, "ERR: required option --dev missing\n");[5d                usage(argv[0], __doc__, long_options, (argc == 1));[6d                return EXIT_FAIL_OPTION;[7d        }[2d(B[m[?25l[2;16H[1K fprintf(stderr, (B[0;1m[33m"ERR: %s() "[3;24H[39m(B[m[1K (B[0;1m[33m"Map type(%d) mismatch expected type(%d)\n"[39m(B[m,[4;24H[1K __func__, info->type, exp->type);[K[5;16H[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[K[6;8H[1K }[K[7d[K[8;9H[35mreturn[39m(B[m 0;[9d}[K[10d[K[11d[32mint[39m(B[m main([32mint[39m(B[m argc, [32mchar[39m(B[m **argv)[12d{[K[13;8H[1K [32mstruct[39m(B[m bpf_map_info map_expect = { 0 };[14;8H[1K [32mstruct[39m(B[m bpf_map_info info = { 0 };[15;8H[1K [32mstruct[39m(B[m xdp_program *program;[K[16;8H[1K [32mint[39m(B[m stats_map_fd;[K[17;8H[1K [32mint[39m(B[m interval = 2;[K[18;8H[1K [32mchar[39m(B[m errmsg[1024];[K[19;8H[1K [32mint[39m(B[m err;[K[21;9H(B[0;7mstruct config cfg = {(B[m[K[22;17H(B[0;7m.ifindex   = -1,[23;9H        .do_unload = false,[24d        };[25d/* Set default BPF-ELF object file and BPF program name */[26;9Hstrncpy(cfg.filename, default_filename, sizeof(cfg.filename));[27;9Hstrncpy(cfg.progname,  default_progname,  sizeof(cfg.progname));[28d        /* Cmdline options can change progname */[29;9Hparse_cmdline_args(argc, argv, long_options, &cfg, __doc__);[30d(B[m[K[31;9H(B[0;7m/* Required option */(B[m[K[32;9H(B[0;7mif (cfg.ifindex == -1) {(B[m[K[33;17H(B[0;7mfprintf(stderr, "ERR: required option --dev missing\n");(B[m[K[34;9H(B[0;7m        usage(argv[0], __doc__, long_options, (argc == 1));[35d                return EXIT_FAIL_OPTION;[36;9H}(B[m[K[37d[K[38;9H(B[0;7m/* Unload a program by prog_id, or[39;10H* unload all programs on net device(B[m[K[40;10H(B[0;7m*/(B[m[K[21d[?12l[?25h[?25l[?12l[?25h[11d(B[0;7mint main(int argc, char **argv)[12d{[13d        struct bpf_map_info map_expect = { 0 };[14d        struct bpf_map_info info = { 0 };[15d        struct xdp_program *program;[16d        int stats_map_fd;[17d        int interval = 2;[18d        char errmsg[1024];[19d        int err;[11d(B[m[?25l[?12l[?25h[8d(B[0;7m        return 0;[9d}[A(B[m[?25l[2d(B[0;1m[34m * values.[39m(B[m[K[3d(B[0;1m[34m */[39m(B[m[K[4d[32mstatic[39m(B[m [32mint[39m(B[m __check_map_fd_info([32mint[39m(B[m map_fd, [32mstruct[39m(B[m bpf_map_info *info,[5;31H[1K [32mstruct[39m(B[m bpf_map_info *exp)[6d{[K[7;9H__u32 info_len = [32msizeof[39m(B[m(*info);[8;8H[1K [32mint[39m(B[m err;[K[9d[K[10;9H(B[0;1m[33mif[39m(B[m (map_fd < 0)[11;16H[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL[39m(B[m;[12d[K[13;8H[1K (B[0;1m[34m/* BPF-info via bpf-syscall */[39m(B[m[K[14;8H[1K err = bpf_obj_get_info_by_fd(map_fd, info, &info_len);[15;8H[1K (B[0;1m[33mif[39m(B[m (err) {[K[16;16H[1K fprintf(stderr, (B[0;1m[33m"ERR: %s() can't get info - %s\n"[39m(B[m,[17;24H[1K __func__,  strerror(errno));[18;16H[1K [35mreturn[39m(B[m (B[0;1m[31mEXIT_FAIL_BPF[39m(B[m;[19;8H[1K }[K[21d(B[0;7mif (exp->key_size && exp->key_size != info->key_size) {[22;17Hfprintf(stderr, "ERR: %s() "[23;17H        "Map key size(%d) mismatch expected size(%d)\n",[24;9H                __func__, info->key_size, exp->key_size);[25;9H        return EXIT_FAIL;(B[m[K[26;9H(B[0;7m}(B[m[K[27d(B[0;7mif (exp->value_size && exp->value_size != info->value_size) {(B[m[K[28;9H(B[0;7m        fprintf(stderr, "ERR: %s() "(B[m[K[29;9H(B[0;7m                "Map value size(%d) mismatch expected size(%d)\n",[30d                        __func__, info->value_size, exp->value_size);[31;9H        return EXIT_FAIL;[32;9H}(B[m[K[33d(B[0;7mif (exp->max_entries && exp->max_entries != info->max_entries) {[34;17Hfprintf(stderr, "ERR: %s() "(B[m[K[35;17H(B[0;7m        "Map max_entries(%d) mismatch expected size(%d)\n",[36;9H                __func__, info->max_entries, exp->max_entries);[37d                return EXIT_FAIL;[38;9H}(B[m[K[39d(B[0;7mif (exp->type && exp->type  != info->type) {[40;10H       fprintf(stderr, "ERR: %s() "[21d(B[m[?12l[?25h[?25l[?12l[?25h[13d(B[0;7m        /* BPF-info via bpf-syscall */[14d        err = bpf_obj_get_info_by_fd(map_fd, info, &info_len);[15d        if (err) {[16d                fprintf(stderr, "ERR: %s() can't get info - %s\n",[17d                        __func__,  strerror(errno));[18d                return EXIT_FAIL_BPF;[19d        }[13d(B[m[?25l[?12l[?25h[10d(B[0;7m        if (map_fd < 0)[11d                return EXIT_FAIL;[A(B[m[?25l[2;41r[2;1H[21T[1;43r[3;9H(B[0;1m[34m/* Print stats "header" */[4;9H[33mif[39m(B[m (verbose) {[5;17Hprintf((B[0;1m[33m"\n"[39m(B[m);[6;17Hprintf((B[0;1m[33m"%-12s\n"[39m(B[m, (B[0;1m[33m"XDP-action"[39m(B[m);[7;9H}[9d(B[0;1m[34m/* Get initial reading quickly */[10;9H[39m(B[mstats_collect(map_fd, map_type, &record);[11;9Husleep(1000000/4);[13;9H(B[0;1m[33mwhile[39m(B[m (1) {[14;17Hprev = record; (B[0;1m[34m/* struct copy */[15;17H[39m(B[mstats_collect(map_fd, map_type, &record);[16;17Hstats_print(&record, &prev);[17;17Hsleep(interval);[18;9H}[19d}[21d(B[0;7m/* Lesson#4: It is userspace responsibility to known what map it is reading and[22d * know the value size. Here get bpf_map_info and check if it match our expected[23d * values.[24d */[25dstatic int __check_map_fd_info(int map_fd, struct bpf_map_info *info,[26d                               struct bpf_map_info *exp)[27d{[28d        __u32 info_len = sizeof(*info);[29d        int err;[21d(B[m[?12l[?25h[?25l[?12l[?25h[13d(B[0;7m        while (1) {[14d                prev = record; /* struct copy */[15d                stats_collect(map_fd, map_type, &record);[16d                stats_print(&record, &prev);[17d                sleep(interval);[18d        }[19d}[13d(B[m[?25l[?12l[?25h[9d(B[0;7m        /* Get initial reading quickly */[10d        stats_collect(map_fd, map_type, &record);[11d        usleep(1000000/4);[9d(B[m[?25l[?12l[?25h[3d(B[0;7m        /* Print stats "header" */[4d        if (verbose) {[5d                printf("\n");[6d                printf("%-12s\n", "XDP-action");[7d        }[3d(B[m[?25l[2;41r[2;1H[21T[1;43r[3;9H(B[0;1m[34m/* Assignment#1: Add byte counters */[4;9H[39m(B[mrec->total.rx_packets = value.rx_packets;[5;9H[35mreturn[39m(B[m true;[6d}[8d[32mstatic[39m(B[m [32mvoid[39m(B[m stats_collect([32mint[39m(B[m map_fd, __u32 map_type,[9;27H[32mstruct[39m(B[m stats_record *stats_rec)[10d{[11;9H(B[0;1m[34m/* Assignment#2: Collect other XDP actions stats  */[12;9H[39m(B[m__u32 key = (B[0;1m[31mXDP_PASS[39m(B[m;[14;9Hmap_collect(map_fd, map_type, key, &stats_rec->stats[0]);[15d}[17d[32mstatic[39m(B[m [32mvoid[39m(B[m stats_poll([32mint[39m(B[m map_fd, __u32 map_type, [32mint[39m(B[m interval)[18d{[19;9H[32mstruct[39m(B[m stats_record prev, record = { 0 };[21d(B[0;7m        /* Trick to pretty printf with thousands separators use %' */[22d        setlocale(LC_NUMERIC, "en_US");[A(B[m[?12l[?25h[?25l[?12l[?25h[17d(B[0;7mstatic void stats_poll(int map_fd, __u32 map_type, int interval)[18d{[19d        struct stats_record prev, record = { 0 };[17d(B[m[?25l[?12l[?25h[14d(B[0;7m        map_collect(map_fd, map_type, key, &stats_rec->stats[0]);[15d}[A(B[m[?25l[?12l[?25h[8d(B[0;7mstatic void stats_collect(int map_fd, __u32 map_type,[9d                          struct stats_record *stats_rec)[10d{[11d        /* Assignment#2: Collect other XDP actions stats  */[12d        __u32 key = XDP_PASS;[8d(B[m[?25l[?12l[?25h[3d(B[0;7m        /* Assignment#1: Add byte counters */[4d        rec->total.rx_packets = value.rx_packets;[5d        return true;[6d}[3d(B[m[?25l[A}[3d[K[4d(B[0;1m[34m/* BPF_MAP_TYPE_PERCPU_ARRAY */[39m(B[m[K[5d[32mvoid[39m(B[m map_get_value_percpu_array([32mint[39m(B[m fd, __u32 key, [32mstruct[39m(B[m datarec *value)[6d{[7;9H(B[0;1m[34m/* For percpu maps, userspace gets a value per possible CPU */[8;8H[39m(B[m[1K (B[0;1m[34m// unsigned int nr_cpus = libbpf_num_possible_cpus();[9;8H[39m(B[m[1K (B[0;1m[34m// struct datarec values[nr_cpus];[39m(B[m[K[10d[K[11;8H[1K fprintf(stderr, (B[0;1m[33m"ERR: %s() not impl. see assignment#3"[39m(B[m, __func__);[12d}[K[14d[32mstatic[39m(B[m [32mbool[39m(B[m map_collect([32mint[39m(B[m fd, __u32 map_type, __u32 key, [32mstruct[39m(B[m record *rec)[15d{[16;9H[32mstruct[39m(B[m datarec value;[17d[K[18;8H[1K (B[0;1m[34m/* Get time as close as possible to reading map contents */[19;8H[39m(B[m[1K rec->timestamp = gettime();[K[21;9H(B[0;7mswitch (map_type) {(B[m[K[22;9H(B[0;7mcase BPF_MAP_TYPE_ARRAY:(B[m[K[23d(B[0;7m                map_get_value_array(fd, key, &value);[24;9H        break;(B[m[K[25;9H(B[0;7mcase BPF_MAP_TYPE_PERCPU_ARRAY:[26;17H/* fall-through */[27;9Hdefault:(B[m[K[28;9H(B[0;7m        fprintf(stderr, "ERR: Unknown map_type(%u) cannot handle\n",[29d                        map_type);[30;9H        return false;(B[m[K[31;9H(B[0;7m        break;(B[m[K[32;9H(B[0;7m}(B[m[K[34d(B[0;7m/* Assignment#1: Add byte counters */[35;9Hrec->total.rx_packets = value.rx_packets;[36;9Hreturn true;(B[m[K[37d(B[0;7m}(B[m[K[38d[K[39d(B[0;7mstatic void stats_collect(int map_fd, __u32 map_type,[40d                          struct stats_record *stats_rec)[21d(B[m[?12l[?25h[?25l[?12l[?25h[18d(B[0;7m        /* Get time as close as possible to reading map contents */[19d        rec->timestamp = gettime();[A(B[m[?25l[?12l[?25h[14d(B[0;7mstatic bool map_collect(int fd, __u32 map_type, __u32 key, struct record *rec)[15d{[16d        struct datarec value;[14d(B[m[?25l[?12l[?25h[11d(B[0;7m        fprintf(stderr, "ERR: %s() not impl. see assignment#3", __func__);[12d}[A(B[m[?25l[?12l[?25h[4d(B[0;7m/* BPF_MAP_TYPE_PERCPU_ARRAY */[5dvoid map_get_value_percpu_array(int fd, __u32 key, struct datarec *value)[6d{[7d        /* For percpu maps, userspace gets a value per possible CPU */[8d        // unsigned int nr_cpus = libbpf_num_possible_cpus();[9d        // struct datarec values[nr_cpus];[4d(B[m[?25l[2;8H[1K {[3;17H[32mchar[39m(B[m *fmt = (B[0;1m[33m"%-12s %'11lld pkts (%'10.0f pps)"[4;24H[39m(B[m[1K (B[0;1m[34m//" %'11lld Kbytes (%'6.0f Mbits/s)"[5;24H[39m(B[m[1K (B[0;1m[33m" period:%f\n"[39m(B[m;[K[6;16H[1K [32mconst[39m(B[m [32mchar[39m(B[m *action = action2str((B[0;1m[31mXDP_PASS[39m(B[m);[7;16H[1K rec  = &stats_rec->stats[0];[K[8;16H[1K prev = &stats_prev->stats[0];[K[9d[K[10;17Hperiod = calc_period(rec, prev);[11;16H[1K (B[0;1m[33mif[39m(B[m (period == 0)[K[12;23H[1K [35mreturn[39m(B[m;[14;16H[1K packets = rec->total.rx_packets - prev->total.rx_packets;[K[15;16H[1K pps     = packets / period;[16d[K[17;17Hprintf(fmt, action, rec->total.rx_packets, pps, period);[18;8H[1K }[K[19d}[K[21d(B[0;7m/* BPF_MAP_TYPE_ARRAY */(B[m[K[22d(B[0;7mvoid map_get_value_array(int fd, __u32 key, struct datarec *value)[23d{(B[m[K[24;9H(B[0;7mif ((bpf_map_lookup_elem(fd, &key, value)) != 0) {[25;9H        fprintf(stderr,(B[m[K[26;17H(B[0;7m        "ERR: bpf_map_lookup_elem failed key:0x%X\n", key);[27;9H}(B[m[K[28d(B[0;7m}(B[m[K[29d[K[30d(B[0;7m/* BPF_MAP_TYPE_PERCPU_ARRAY */[31dvoid map_get_value_percpu_array(int fd, __u32 key, struct datarec *value)[32d{(B[m[K[33d(B[0;7m        /* For percpu maps, userspace gets a value per possible CPU */[34;10H/ unsigned int nr_cpus = libbpf_num_possible_cpus();[35;9H// struct datarec values[nr_cpus];(B[m[K[36d[K[37d(B[0;7m        fprintf(stderr, "ERR: %s() not impl. see assignment#3", __func__);[38d}[39d(B[m[K[40d(B[0;7mstatic bool map_collect(int fd, __u32 map_type, __u32 key, struct record *rec)[21d(B[m[?12l[?25h[?25l[?12l[?25h[17d(B[0;7m                printf(fmt, action, rec->total.rx_packets, pps, period);[18d        }[19d}[17d(B[m[?25l[?12l[?25h[14d(B[0;7m                packets = rec->total.rx_packets - prev->total.rx_packets;[15d                pps     = packets / period;[A(B[m[?25l[?12l[?25h[10d(B[0;7m                period = calc_period(rec, prev);[11d                if (period == 0)[12d                       return;[10d(B[m[?25l[2;40r[2;1H[20T[1;43r[2;1H{[3;9H[32mdouble[39m(B[m period_ = 0;[4;9H__u64 period = 0;[6;9Hperiod = r->timestamp - p->timestamp;[7;9H(B[0;1m[33mif[39m(B[m (period > 0)[8;17Hperiod_ = (([32mdouble[39m(B[m) period / (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m);[10;9H[35mreturn[39m(B[m period_;[11d}[13d[32mstatic[39m(B[m [32mvoid[39m(B[m stats_print([32mstruct[39m(B[m stats_record *stats_rec,[14;25H[32mstruct[39m(B[m stats_record *stats_prev)[15d{[16;9H[32mstruct[39m(B[m record *rec, *prev;[17;9H[32mdouble[39m(B[m period;[18;9H__u64 packets;[19;9H[32mdouble[39m(B[m pps; (B[0;1m[34m/* packets per sec */[21d[39m(B[0;7m        /* Assignment#2: Print other XDP actions stats  */[22d        {[23d                char *fmt = "%-12s %'11lld pkts (%'10.0f pps)"[24d                        //" %'11lld Kbytes (%'6.0f Mbits/s)"[25d                        " period:%f\n";[26d                const char *action = action2str(XDP_PASS);[27d                rec  = &stats_rec->stats[0];[28d                prev = &stats_prev->stats[0];[21d(B[m[?12l[?25h[?25l[?12l[?25h[13d(B[0;7mstatic void stats_print(struct stats_record *stats_rec,[14d                        struct stats_record *stats_prev)[15d{[16d        struct record *rec, *prev;[17d        double period;[18d        __u64 packets;[19d        double pps; /* packets per sec */[13d(B[m[?25l[?12l[?25h[10d(B[0;7m        return period_;[11d}[A(B[m[?25l[?12l[?25h[6d(B[0;7m        period = r->timestamp - p->timestamp;[7d        if (period > 0)[8d                period_ = ((double) period / NANOSEC_PER_SEC);[6d(B[m[?25l[2;40r[2;1H[20T[1;43r[2;9H[32mint[39m(B[m res;[4;9Hres = clock_gettime((B[0;1m[31mCLOCK_MONOTONIC[39m(B[m, &t);[5;9H(B[0;1m[33mif[39m(B[m (res < 0) {[6;17Hfprintf(stderr, (B[0;1m[33m"Error with gettimeofday! (%i)\n"[39m(B[m, res);[7;17Hexit((B[0;1m[31mEXIT_FAIL[39m(B[m);[8;9H}[9d[35mreturn[39m(B[m (__u64) t.tv_sec * (B[0;1m[31mNANOSEC_PER_SEC[39m(B[m + t.tv_nsec;[10d}[12d[32mstruct[39m(B[m record {[13;9H__u64 timestamp;[14;9H[32mstruct[39m(B[m datarec total; (B[0;1m[34m/* defined in common_kern_user.h */[15d[39m(B[m};[17d[32mstruct[39m(B[m stats_record {[18;9H[32mstruct[39m(B[m record stats[1]; (B[0;1m[34m/* Assignment#2: Hint */[19d[39m(B[m};[21d(B[0;7mstatic double calc_period(struct record *r, struct record *p)[22d{[23d        double period_ = 0;[24d        __u64 period = 0;[21d(B[m[?12l[?25h[?25l[?12l[?25h[17d(B[0;7mstruct stats_record {[18d        struct record stats[1]; /* Assignment#2: Hint */[19d};[17d(B[m[?25l[?12l[?25h[12d(B[0;7mstruct record {[13d        __u64 timestamp;[14d        struct datarec total; /* defined in common_kern_user.h */[15d};[12d(B[m[?25l[?12l[?25h[4d(B[0;7m        res = clock_gettime(CLOCK_MONOTONIC, &t);[5d        if (res < 0) {[6d                fprintf(stderr, "Error with gettimeofday! (%i)\n", res);[7d                exit(EXIT_FAIL);[8d        }[9d        return (__u64) t.tv_sec * NANOSEC_PER_SEC + t.tv_nsec;[10d}[4d(B[m[?25l[2d};[K[4d[32mint[39m(B[m find_map_fd([32mstruct[39m(B[m bpf_object *bpf_obj, [32mconst[39m(B[m [32mchar[39m(B[m *mapname)[5d{[K[6;8H[1K [32mstruct[39m(B[m bpf_map *map;[K[7;8H[1K [32mint[39m(B[m map_fd = -1;[K[8d[K[9;8H[1K (B[0;1m[34m/* Lesson#3: bpf_object to bpf_map */[39m(B[m[K[10;8H[1K map = bpf_object__find_map_by_name(bpf_obj, mapname);[11;9H(B[0;1m[33mif[39m(B[m (!map) {[12;16H[1K fprintf(stderr, (B[0;1m[33m"ERR: cannot find map by name: %s\n"[39m(B[m, mapname);[13;16H[1K [35mgoto[39m(B[m out;[14;8H[1K }[K[15d[K[16;9Hmap_fd = bpf_map__fd(map);[17d(B[0;1m[35m out(B[0m:(B[m[K[18d  [1K [35mreturn[39m(B[m map_fd;[K[19d}[K[21d(B[0;7m#define NANOSEC_PER_SEC 1000000000 /* 10^9 */(B[m[K[22d(B[0;7mstatic __u64 gettime(void)[23d{(B[m[K[24;9H(B[0;7mstruct timespec t;[25d        int res;[26d(B[m[K[27;9H(B[0;7mres = clock_gettime(CLOCK_MONOTONIC, &t);[28;9Hif (res < 0) {(B[m[K[29d(B[0;7m                fprintf(stderr, "Error with gettimeofday! (%i)\n", res);[30;9H        exit(EXIT_FAIL);[31d        }[32d        return (__u64) t.tv_sec * NANOSEC_PER_SEC + t.tv_nsec;[33d}(B[m[K[34d[K[35d(B[0;7mstruct record {[36;9H__u64 timestamp;(B[m[K[37;9H(B[0;7mstruct datarec total; /* defined in common_kern_user.h */[38d};(B[m[K[39d[K[40d(B[0;7mstruct stats_record {[21d(B[m[?12l[?25h[?25l[?12l[?25h[16d(B[0;7m        map_fd = bpf_map__fd(map);[17d out:[18d        return map_fd;[19d}[16d(B[m[?25l[?12l[?25h[9d(B[0;7m        /* Lesson#3: bpf_object to bpf_map */[10d        map = bpf_object__find_map_by_name(bpf_obj, mapname);[11d        if (!map) {[12d                fprintf(stderr, "ERR: cannot find map by name: %s\n", mapname);[13d                goto out;[14d        }[9d(B[m[?25l[?12l[?25h[4d(B[0;7mint find_map_fd(struct bpf_object *bpf_obj, const char *mapname)[5d{[6d        struct bpf_map *map;[7d        int map_fd = -1;[4d(B[m[?25l[2;40r[2;1H[20T[1;43r[3;9H{{(B[0;1m[33m"auto-mode"[39m(B[m,   no_argument,[3;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'A'[39m(B[m },[4;10H(B[0;1m[33m"Auto-detect SKB or native mode"[39m(B[m},[6;9H{{(B[0;1m[33m"unload"[39m(B[m,[26Grequired_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'U'[39m(B[m },[7;10H(B[0;1m[33m"Unload XDP program <id> instead of loading"[39m(B[m, (B[0;1m[33m"<id>"[39m(B[m},[9;9H{{(B[0;1m[33m"unload-all"[39m(B[m,  no_argument,[9;49H(B[0;1m[31mNULL[39m(B[m,  4  },[10;10H(B[0;1m[33m"Unload all XDP programs on device"[39m(B[m},[12;9H{{(B[0;1m[33m"quiet"[39m(B[m,[26Gno_argument,[12;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'q'[39m(B[m },[13;10H(B[0;1m[33m"Quiet mode (no output)"[39m(B[m},[15;9H{{(B[0;1m[33m"filename"[39m(B[m,    required_argument,     (B[0;1m[31mNULL[39m(B[m,  1  },[16;10H(B[0;1m[33m"Load program from <file>"[39m(B[m, (B[0;1m[33m"<file>"[39m(B[m},[18;9H{{(B[0;1m[33m"progname"[39m(B[m,    required_argument,     (B[0;1m[31mNULL[39m(B[m,  2  },[19;10H(B[0;1m[33m"Load program from function <name> in the ELF file"[39m(B[m, (B[0;1m[33m"<name>"[39m(B[m},[21d(B[0;7m        {{0, 0, NULL,  0 }}[22d};[A(B[m[?12l[?25h[?25l[?12l[?25h[18d(B[0;7m        {{"progname",    required_argument,     NULL,  2  },[19d         "Load program from function <name> in the ELF file", "<name>"},[A(B[m[?25l[?12l[?25h[15d(B[0;7m        {{"filename",    required_argument,     NULL,  1  },[16d         "Load program from <file>", "<file>"},[A(B[m[?25l[?12l[?25h[12d(B[0;7m        {{"quiet",       no_argument,           NULL, 'q' },[13d         "Quiet mode (no output)"},[A(B[m[?25l[?12l[?25h[9d(B[0;7m        {{"unload-all",  no_argument,           NULL,  4  },[10d         "Unload all XDP programs on device"},[A(B[m[?25l[?12l[?25h[6d(B[0;7m        {{"unload",      required_argument,     NULL, 'U' },[7d         "Unload XDP program <id> instead of loading", "<id>"},[A(B[m[?25l[?12l[?25h[3d(B[0;7m        {{"auto-mode",   no_argument,           NULL, 'A' },[4d         "Auto-detect SKB or native mode"},[A(B[m[?25l[2;41r[2;1H[21T[1;43r[2;1H(B[0;1m[36m#include[33m <linux/if_link.h>[39m(B[m (B[0;1m[34m/* depend on kernel-headers installed */[4d[36m#include[39m(B[m (B[0;1m[33m"../common/common_params.h"[5d[36m#include[39m(B[m (B[0;1m[33m"../common/common_user_bpf_xdp.h"[6d[36m#include[39m(B[m (B[0;1m[33m"common_kern_user.h"[8d(B[0m[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *default_filename = (B[0;1m[33m"xdp_prog_kern.o"[39m(B[m;[9d[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *default_progname = (B[0;1m[33m"xdp_stats1_func"[39m(B[m;[11d[32mstatic[39m(B[m [32mconst[39m(B[m [32mstruct[39m(B[m option_wrapper long_options[] = {[12;9H{{(B[0;1m[33m"help"[39m(B[m,[12;26Hno_argument,[12;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'h'[39m(B[m },[13;10H(B[0;1m[33m"Show help"[39m(B[m, false},[15;9H{{(B[0;1m[33m"dev"[39m(B[m,[15;26Hrequired_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'd'[39m(B[m },[16;10H(B[0;1m[33m"Operate on device <ifname>"[39m(B[m, (B[0;1m[33m"<ifname>"[39m(B[m, true},[18;9H{{(B[0;1m[33m"skb-mode"[39m(B[m,    no_argument,[18;49H(B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'S'[39m(B[m },[19;10H(B[0;1m[33m"Install XDP program in SKB (AKA generic) mode"[39m(B[m},[21d(B[0;7m        {{"native-mode", no_argument,           NULL, 'N' },[22d         "Install XDP program in native mode"},[A(B[m[?12l[?25h[?25l[?12l[?25h[18d(B[0;7m        {{"skb-mode",    no_argument,           NULL, 'S' },[19d         "Install XDP program in SKB (AKA generic) mode"},[A(B[m[?25l[?12l[?25h[15d(B[0;7m        {{"dev",         required_argument,     NULL, 'd' },[16d         "Operate on device <ifname>", "<ifname>", true},[A(B[m[?25l[?12l[?25h[11d(B[0;7mstatic const struct option_wrapper long_options[] = {[12d        {{"help",        no_argument,           NULL, 'h' },[13d         "Show help", false},[11d(B[m[?25l[?12l[?25h[8d(B[0;7mstatic const char *default_filename = "xdp_prog_kern.o";[9dstatic const char *default_progname = "xdp_stats1_func";[A(B[m[?25l[?12l[?25h[4d(B[0;7m#include "../common/common_params.h"[5d#include "../common/common_user_bpf_xdp.h"[6d#include "common_kern_user.h"[4d(B[m[?25l[2;40r[2;1H[19T[1;43r[2;1H(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d(B[0m[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *__doc__ = (B[0;1m[33m"XDP loader and stats program\n"[4;9H" - Allows selecting BPF --progname name to XDP-attach to --dev\n"[39m(B[m;[6d(B[0;1m[36m#include[33m <stdio.h>[7d[36m#include[33m <stdlib.h>[8d[36m#include[33m <string.h>[9d[36m#include[33m <errno.h>[10d[36m#include[33m <getopt.h>[12d[36m#include[33m <locale.h>[13d[36m#include[33m <unistd.h>[14d[36m#include[33m <time.h>[16d[36m#include[33m <bpf/bpf.h>[17d[36m#include[33m <bpf/libbpf.h>[18d[36m#include[33m <xdp/libxdp.h>[20d[39m(B[0;7m#include <net/if.h>[21d#include <linux/if_link.h> /* depend on kernel-headers installed */[A(B[m[?12l[?25h[?25l[?12l[?25h[16d(B[0;7m#include <bpf/bpf.h>[17d#include <bpf/libbpf.h>[18d#include <xdp/libxdp.h>[16d(B[m[?25l[?12l[?25h[12d(B[0;7m#include <locale.h>[13d#include <unistd.h>[14d#include <time.h>[12d(B[m[?25l[?12l[?25h[6d(B[0;7m#include <stdio.h>[7d#include <stdlib.h>[8d#include <string.h>[9d#include <errno.h>[10d#include <getopt.h>[6d(B[m[?25l[?12l[?25h[2d(B[0;7m/* SPDX-License-Identifier: GPL-2.0 */[3dstatic const char *__doc__ = "XDP loader and stats program\n"[4d        " - Allows selecting BPF --progname name to XDP-attach to --dev\n";[2d(B[m[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[?12l[?25h[?25l[1;99H(B[0;7m    (B[m[2d(B[0;1m[34m/* SPDX-License-Identifier: GPL-2.0 */[3d(B[0m[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *__doc__ = (B[0;1m[33m"XDP loader and stats program\n"[4;8H[39m(B[m[1K (B[0;1m[33m" - Allows selecting BPF --progname name to XDP-attach to --dev\n"[39m(B[m;[6d(B[0;1m[36m#include[33m <stdio.h>[7d[36m#include[33m <stdlib.h>[8d[36m#include[33m <string.h>[9d[36m#include[33m <errno.h>[10d[36m#include[33m <getopt.h>[12d[36m#include[33m <locale.h>[13d[36m#include[33m <unistd.h>[14d[36m#include[33m <time.h>[16d[36m#include[33m <bpf/bpf.h>[17d[36m#include[33m <bpf/libbpf.h>[18d[36m#include[33m <xdp/libxdp.h>[20d[36m#include[33m <net/if.h>[21d[36m#include[33m <linux/if_link.h>[39m(B[m (B[0;1m[34m/* depend on kernel-headers installed */[23d[36m#include[39m(B[m (B[0;1m[33m"../common/common_params.h"[24d[36m#include[39m(B[m (B[0;1m[33m"../common/common_user_bpf_xdp.h"[25d[36m#include[39m(B[m (B[0;1m[33m"common_kern_user.h"[27d(B[0m[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *default_filename = (B[0;1m[33m"xdp_prog_kern.o"[39m(B[m;[28d[32mstatic[39m(B[m [32mconst[39m(B[m [32mchar[39m(B[m *default_progname = (B[0;1m[33m"xdp_stats1_func"[39m(B[m;[30d[32mstatic[39m(B[m [32mconst[39m(B[m [32mstruct[39m(B[m option_wrapper long_options[] = {[31;8H[1K {{(B[0;1m[33m"help"[39m(B[m,        no_argument,           (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'h'[39m(B[m },[32;9H[1K (B[0;1m[33m"Show help"[39m(B[m, false},[34;8H[1K {{(B[0;1m[33m"dev"[39m(B[m,         required_argument,     (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'd'[39m(B[m },[35;9H[1K (B[0;1m[33m"Operate on device <ifname>"[39m(B[m, (B[0;1m[33m"<ifname>"[39m(B[m, true},[37;8H[1K {{(B[0;1m[33m"skb-mode"[39m(B[m,    no_argument,           (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'S'[39m(B[m },[38;9H[1K (B[0;1m[33m"Install XDP program in SKB (AKA generic) mode"[39m(B[m},[40;8H[1K {{(B[0;1m[33m"native-mode"[39m(B[m, no_argument,           (B[0;1m[31mNULL[39m(B[m, (B[0;1m[35m'N'[39m(B[m },[2d[?12l[?25h[?25l[42d[J[43d[?12l[?25h[43;1H[?1049l[23;0;0t[?1l>[?2004l[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ code xdp_load_and_stats.c
[?2004lCommand 'code' not found, but can be installed with:
sudo snap install code
[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ code xdp_load_and_stats.c[Kcode xdp_load_and_stats.c
[?2004l[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ make
[?2004l    CC       xdp_load_and_stats
[01m[Kxdp_load_and_stats.c:[m[K In function ‘[01m[Kstats_print[m[K’:
[01m[Kxdp_load_and_stats.c:128:25:[m[K [01;35m[Kwarning: [m[Kstatement with no effect [[01;35m[K]8;;https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wunused-value-Wunused-value]8;;[m[K]
  128 |                         [01;35m[K" period:%f\n"[m[K;
      |                         [01;35m[K^~~~~~~~~~~~~~[m[K
    CLANG    xdp_prog_kern.o
[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ make clean
[?2004l[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ make
[?2004l    CC       xdp_load_and_stats
    CLANG    xdp_prog_kern.o
[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ [7msudo ./xdp_loader --dev eth0[27msudo ./xdp_loader --dev eth0
[?2004l[sudo] password for xainecks: 
sudo: ./xdp_loader: command not found
[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ ip link
[?2004l1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: enp8s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 10:7c:61:77:cd:8c brd ff:ff:ff:ff:ff:ff
[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ [7msudo ./xdp_loader --dev enp8s0[27m
[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Csudo ./xdp_loader --dev enp8s0
[A
[?2004lsudo: ./xdp_loader: command not found
[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ ls
[?2004lcommon_kern_user.h  README.org          xdp_load_and_stats.c  xdp_prog_kern.o
Makefile            [0m[01;32mxdp_load_and_stats[0m  xdp_prog_kern.c
[?2004h]0;xainecks@xainecks-PC1: ~/XDP/xdp-tutorial/basic03-map-counter[01;32mxainecks@xainecks-PC1[00m:[01;34m~/XDP/xdp-tutorial/basic03-map-counter[00m$ [7msudo ./xdp_load_and_stats --dev lo[27msudo ./xdp_load_and_stats --dev lo
[?2004llibbpf: elf: skipping unrecognized data section(7) xdp_metadata
libbpf: elf: skipping unrecognized data section(7) xdp_metadata
libbpf: elf: skipping unrecognized data section(7) xdp_metadata
libbpf: elf: skipping unrecognized data section(7) xdp_metadata
Success: Loaded BPF-object(xdp_prog_kern.o) and used section(xdp_stats1_func)
 - XDP prog id:87 attached on device:lo(ifindex:1)

Collecting stats from BPF map
 - BPF map (bpf_map_type:2) id:13 name:xdp_stats_map key_size:4 value_size:16 max_entries:5

XDP-action  
XDP_PASS               2 pkts (         8 pps)         180 bytes period:0.250076
XDP_PASS               2 pkts (         0 pps)         180 bytes period:2.000094
XDP_PASS               2 pkts (         0 pps)         180 bytes period:2.000080
XDP_PASS               2 pkts (         0 pps)         180 bytes period:2.000088
XDP_PASS               2 pkts (         0 pps)         180 bytes period:2.000082
XDP_PASS               2 pkts (         0 pps)         180 bytes period:2.000078
XDP_PASS               2 pkts (         0 pps)         180 bytes period:2.000093
XDP_PASS               2 p